{
    "collab_server" : "",
    "contents" : "logitinv=function(x) 1/(1+exp(-x))\nlogit=function(p) log(p/(1-p))\n\n####################################\n############ Creation ##############\n####################################\n\n##########  MSM.fitted   ##############\n\n########\n#####Class definition\nsetClass(\"MSM.fitted\",\n\trepresentation(\n\t\tCondMean\t= \"matrix\",\n\t\terror\t\t= \"matrix\",\n\t\tLikel\t\t= \"matrix\",\n\t\tmargLik\t= \"matrix\",\n\t\tfiltProb\t= \"matrix\",\n\t\tsmoProb\t= \"matrix\",\n\t\tsmoTransMat\t= \"list\",\n\t\tlogLikel\t= \"numeric\"\n\t)\n)\n\n####################################\n##### Construction, get and set ####\n####################################\n\n##### Get\nsetMethod(\n\tf=\"[\",\n\tsignature=c(\"MSM.fitted\",\"character\",\"missing\",\"missing\"),\n\tdef = function(x,i,j,drop){\n\t\tswitch(EXP=i,\n\t\t\tCondMean\t= return(x@CondMean),\n\t\t\terror\t\t= return(x@error),\n\t\t\tLikel \t= return(x@Likel),\n\t\t\tmargLik \t= return(x@margLik),\n\t\t\tfiltProb \t= return(x@filtProb),\n\t\t\tsmoProb \t= return(x@smoProb),\n\t\t\tstates\t= return(apply(x@smoProb,1,which.max)),\n\t\t\tsmoTransMat\t= return(x@smoTransMat),\n\t\t\tlogLikel \t= return(x@logLikel),\n\t\t\tstop(\"Error:\",i,\"is not a MSM.fitted slot\")\n\t\t)\n\t}\n)\n\n\n#############################################\n#############################################\n#############################################\n#############################################\n#############################################\n#############################################\n\n############  MSM   ################\n\n####################################\n############ Creation ##############\n####################################\n\n##########\n#####Validity function\nvalidMSM=function(object){\n\tif(object@k<=0){\n\t\tstop(\"A negative k is not possible!\")\n\t}else{}\n}\n\n########\n#####Class definition\n\nsetClass(\n\tClass=\"MSM\",\n\trepresentation=representation(\n\t\tcall \t= \"call\",\n\t\tk      \t= \"numeric\",\n\t\tswitch \t= \"logical\",\n\t\tp\t= \"numeric\",\n\t\tFit \t= \"MSM.fitted\"\n\t)\n)\n\n#############################################\n#############################################\n#############################################\n#############################################\n#############################################\n#############################################\n\n#########  MSM.linear   ############\n\n####################################\n############ Creation ##############\n####################################\n\n##########\n#####Validity function\nvalidMSM.linear=function(object){\n\tif(min(object@transMat)<0 | max(object@transMat)>1) {\n\t\tstop(\"A probability must be a value between 0 and 1!\")\n\t}\n\tif(object@p<0){\n\t\tstop(\"The number of AR coefficients has to be positive or zero\\n\")\n\t}\n\treturn(invisible())\n\n}\n\nvalidMSM.lm=function(object){\n\tif(any(object@std<0)) stop(\"A negative std is not possible!\")\n\tif(length(object@switch)!=ncol(object@Coef)+1){\n\t\tstop(\"The length of sw has to be equal of the number of coefficients in the model plus 1\\n\")\n\t}\n\treturn(invisible())\n\n}\n\nvalidMSM.glm=function(object){\n\tif(length(object@switch)!=ncol(object@Coef)){\n\t\tstop(\"The length of sw has to be equal of the number of coefficients in the model\\n\")\n\t}\n\tswitch(object@family$family,\n\t\tpoisson=return(invisible()),\n\t\tbinomial=return(invisible()),\n\t\tgaussian=return(invisible()),\n\t\tGamma=return(invisible()),\n\t\tstop(\"The family is not poisson, binomial, gaussian or Gamma!\")\n\t)\n\treturn(invisible())\n\n}\n\n\n########\n#####Class definition\nsetClass(\n\tClass= \"MSM.linear\",\n\trepresentation=representation(\n\t\t\tmodel  \t\t= \"lm\",\n\t\t\tCoef  \t\t= \"data.frame\",\n\t\t\tseCoef \t\t= \"data.frame\",\n\t\t\ttransMat\t= \"matrix\",\n\t\t\tiniProb \t= \"numeric\"\n\t),\n\tcontains=\"MSM\"\n)\nsetClass(\n\tClass= \"MSM.lm\",\n\trepresentation=representation(\n\t\t\tstd = \"numeric\"\n\t),\n\tcontains=\"MSM.linear\"\n)\n\nsetClass(\n\tClass= \"MSM.glm\",\n\trepresentation=representation(\n\t\t\tfamily = \"ANY\",\n\t\t\tLikelihood  = \"function\"\n\t),\n\tcontains=\"MSM.linear\"\n)\n\n####################################\n##### Construction, get and set ####\n####################################\n\n#### Constructor\nmsmControl <- function(trace = F,  maxiter = 100, tol = 1e-8, maxiterInner=10, maxiterOuter=5, parallelization=T)\n### Control parameters for lmer, glmer and nlmer\n{\n    stopifnot(maxiter >= 0, tol >= 0, maxiterInner >= 0,maxiterOuter >= 0)\n    list(\n\t\tmaxiter = as.integer(maxiter),\n        tol = as.numeric(tol),\n\t\ttrace = as.logical(trace),\n\t\tmaxiterInner = as.integer(maxiterInner),\n\t\tmaxiterOuter = as.integer(maxiterOuter),\n\t\tparallelization = as.logical(parallelization)\n\t)\n}\n\n\n.MSM.formula.msmFit = function(object,k,sw,p,data,family,control){\n\tcall=match.call()\n\tif (missing(family)) {\n\t\tmodel=lm(object,data)\n\t}else{\n\t\tmodel=glm(object,data,family=family)\n\t}\n\tif(missing(p)) p=0\n\tdata=list(call)\n\tif(missing(family)&missing(control)){\n\t\tmsmFit(model,k,sw,p)\n\t}else{\n\t\tif(missing(family)){\n\t\t\tmsmFit(model,k,sw,p,control=control)\n\t\t}else{\n\t\t\tif(missing(control)){\n\t\t\t\tmsmFit(model,k,sw,p,family=family)\n\t\t\t}else{\n\t\t\t\tmsmFit(model,k,sw,p,family=family,control=control)\n\t\t\t}\n\t\t}\n\t}\n}\nsetMethod(f=\"msmFit\",signature=c(\"formula\",\"numeric\",\"logical\",\"ANY\",\"data.frame\",\"ANY\",\"ANY\"),definition=.MSM.formula.msmFit)\n\n\n.MSM.lm.msmFit= function(object,k,sw,p,data,family,control){\n\tif(!missing(data)){\n\t\tif(is.list(data)){\n\t\t\tif(class(data[[1]])==\"call\"){\n\t\t\t\tcall=data[[1]]\n\t\t\t}else{\n\t\t\t\tcall=match.call()\n\t\t\t}\n\t\t}else{\n\t\t\tcall=match.call()\n\t\t}\n\t}else{\n\t\tcall=match.call()\n\t}\n\tif(missing(p)) p=0\n\tif (missing(control)) control=list()\n   \tcontrol  <- do.call(msmControl, control)\n\n\n\tif(p>0){\n\t\tvar=object$model[,1]\n\t\tAr=apply(as.matrix(1:p),1,function(el){\n\t\t\t\tlength(var)=length(var)-el\n\t\t\t\tvar=c(rep(NA,el),var)\n\t\t\t\treturn(var)\n\t\t\t}\n\t\t)\n\t\tcolnames(Ar)=paste(names(object$model)[1],\"_\",1:p,sep=\"\")\n\t\taux=paste(colnames(Ar),collapse=\"+\")\n\t\tobject=update(formula=as.formula(paste(\"~.+\",aux,sep=\"\")),data=data.frame(object$model,Ar),object)\n\n\t}\n\n\tCoef=data.frame(matrix(NA,nrow=k,ncol=length(coef(object))))\n\tstd=rep(0,k)\n\n\tind=sample(1:k,length(object$residuals),replace=T)\n\n\tfor(i in 1:k){\n\t\tdata1=as.data.frame(object$model[ind==i,,drop=F])\n\t\tmod1=update(object,formula=object$terms,data=data1)\n\t\tCoef[i,]=coef(mod1)\n\t\tstd[i]=summary(mod1)$sigma\n\t}\n\n\tnames(Coef)=names(coef(object))\n\ttransMat=t(matrix(table(ind,c(ind[-1],NA))/rep(table(ind[-length(ind)]),k),ncol=k))\n\tans=new(Class=\"MSM.lm\",\n\t\tcall=as.call(call),\n\t\tmodel=object,\n\t\tk=k,\n\t\tswitch=sw,\n\t\tp=p,\n\t\tCoef=Coef,\n\t\tstd=std,\n\t\ttransMat=transMat,\n\t\tiniProb= rep(1/k,k)\n\t)\n\tvalidMSM.linear(ans)\n\tvalidMSM.lm(ans)\n\tans=em(ans,control)\n\treturn(ans)\n}\nsetMethod(f=\"msmFit\",signature=c(\"lm\",\"numeric\",\"logical\",\"ANY\",\"missing\",\"missing\",\"ANY\"),definition=.MSM.lm.msmFit)\n\n\n.MSM.glm.msmFit = function(object,k,sw,p,data,family,control){\n\tif(!missing(data)){\n\t\tif(is.list(data)){\n\t\t\tif(class(data[[1]])==\"call\"){\n\t\t\t\tcall=data[[1]]\n\t\t\t}else{\n\t\t\t\tcall=match.call()\n\t\t\t}\n\t\t}else{\n\t\t\tcall=match.call()\n\t\t}\n\t}else{\n\t\tcall=match.call()\n\t}\n\tif(missing(p)) p=0\n\tif (missing(control)) control=list()\n   \tcontrol  <- do.call(msmControl, control)\n\n\tif(p>0){\n\t\tvar=object$model[,1]\n\t\tAr=apply(as.matrix(1:p),1,function(el){\n\t\t\t\tlength(var)=length(var)-el\n\t\t\t\tvar=c(rep(NA,el),var)\n\t\t\t\treturn(var)\n\t\t\t}\n\t\t)\n\t\tcolnames(Ar)=paste(names(object$model)[1],\"_\",1:p,sep=\"\")\n\t\taux=paste(colnames(Ar),collapse=\"+\")\n\t\tobject=update(formula=as.formula(paste(\"~.+\",aux,sep=\"\")),data=data.frame(object$model,Ar),object)\n\n\t}\n\n\n\tCoef=data.frame(matrix(NA,nrow=k,ncol=length(coef(object))))\n\tind=findInterval(object$residuals,quantile(object$residuals,(1:(k-1))/k))+1\n\tfor(i in 1:k){\n\t\tdata1=object$model[ind==i,,drop=F]\n\t\tmod1=update(object,data=data1)\n\t\tCoef[i,]=coef(mod1)\n\t}\n\tnames(Coef)=names(coef(object))\n\n\ttransMat=t(matrix(table(ind,c(ind[-1],NA))/rep(table(ind[-length(ind)]),k),ncol=k))\n\n\n\tLikelihood = switch(object$family$family,\n\t\t\tpoisson=function(x,mu) dpois(x,lambda=mu),\n\t\t\tbinomial=function(x,mu) dbinom(x,prob=mu,size=1),\n\t\t\tgaussian=function(x,mu) dnorm(x,mean=mu,sd=1),\n\t\t\tGamma=function(x,mu) dgamma(x,shape=mu,rate=1),\n\t\t\t\"error\"\n\t)\n\n\tans=new(Class=\"MSM.glm\",\n\t\tcall=as.call(call),\n\t\tmodel=object,\n\t\tk=k,\n\t\tswitch=sw,\n\t\tp=p,\n\t\tCoef=Coef,\n\t\ttransMat=transMat,\n\t\tiniProb= rep(1/k,k),\n\n\t\tfamily=object$family,\n\t\tLikelihood=Likelihood\n\t)\n\tvalidMSM.linear(ans)\n\tvalidMSM.glm(ans)\n\tans=em(ans,control)\n\treturn(ans)\n}\nsetMethod(f=\"msmFit\",signature=c(\"glm\",\"numeric\",\"logical\",\"ANY\",\"missing\",\"ANY\",\"ANY\"),definition=.MSM.glm.msmFit)\n\n\n##### Get\nsetMethod(\n\tf=\"[\",\n\tsignature=c(\"MSM.lm\",\"character\",\"missing\",\"missing\"),\n\tdef = function(x,i,j,drop){\n\t\tswitch(EXP=i,\n\t\t\tcall = return(x@call),\n\t\t\tmodel = return(x@model),\n\t\t\tk = return(x@k),\n\t\t\tswitch = return(x@switch),\n\t\t\tCoef = return(x@Coef),\n\t\t\tseCoef = return(x@seCoef),\n\t\t\tstd = return(x@std),\n\t\t\ttransMat = return(x@transMat),\n\t\t\tiniProb = return(x@iniProb),\n\t\t\tFit = return(x@Fit),\n\t\t\tstates = return(x@Fit[\"states\"]),\n\t\t\tstop(\"Error:\",i,\"is not a MSM slot\")\n\t\t)\n\t}\n)\n\n\n##### Get\nsetMethod(\n\tf=\"[\",\n\tsignature=c(\"MSM.glm\",\"character\",\"missing\",\"missing\"),\n\tdef = function(x,i,j,drop){\n\t\tswitch(EXP=i,\n\t\t\tcall = return(x@call),\n\t\t\tmodel = return(x@model),\n\t\t\tk = return(x@k),\n\t\t\tswitch = return(x@switch),\n\t\t\tCoef = return(x@Coef),\n\t\t\tseCoef = return(x@seCoef),\n\t\t\ttransMat = return(x@transMat),\n\t\t\tiniProb = return(x@iniProb),\n\t\t\tFit = return(x@Fit),\n\t\t\tstates = return(x@Fit[\"states\"]),\n\t\t\tfamily = return(x@family),\n\t\t\tstop(\"Error:\",i,\"is not a MSM slot\")\n\t\t)\n\t}\n)\n\n\n####################################\n########### Functions ##############\n####################################\n\n##########\n##### show\n\n.MSM.lm.show=function(object){\n\tcat(\"Markov Switching Model\\n\")\n\tcat(\"\\nCall: \")\n\tprint(object[\"call\"])\n\tswi=object@switch[-length(object@switch)]\n\tnp=object[\"k\"]*sum(swi)+sum(!swi)\n\tAIC=2*object[\"Fit\"][\"logLikel\"]+2*np\n\tBIC=2*object[\"Fit\"][\"logLikel\"]+2*np*log(nrow(object@model$model))\n\tcat(\"\\n\")\n\tprint(data.frame(AIC = AIC, BIC = BIC, logLik = -object[\"Fit\"][\"logLikel\"],\n        row.names = \" \"))\n\tsw=apply(as.matrix(object@switch),1,function(x){\n\t\t\tif(x){\n\t\t\t\treturn(\"(S)\")\n\t\t\t}else{\n\t\t\t\treturn(\"\")\n\t\t\t\t}\n\t\t}\n\t)\n\ttau=as.matrix(cbind(object[\"Coef\"],object[\"std\"]))\n\tdimnames(tau)=list(c(paste(rep(\"Model\",object[\"k\"]),as.character(c(1:object[\"k\"])))),c(paste(c(names(object[\"Coef\"]),\"Std\"),sw,sep=\"\")))\n\tcat(\"\\nCoefficients:\\n\")\n   \tprint(tau)\n\tcat(\"\\nTransition probabilities:\\n\")\n\tpro=object[\"transMat\"]\n\tdimnames(pro)=rep(list(paste(\"Regime\",1:object[\"k\"])),2)\n\tprint(pro)\n\treturn(invisible())\n}\nsetMethod(f=\"show\",signature=\"MSM.lm\",definition=.MSM.lm.show)\n\n\n.MSM.glm.show=function(object){\n\tcat(\"Markov Switching Model\\n\")\n\tcat(\"\\nCall: \")\n\tprint(object[\"call\"])\n\tswi=object@switch\n\tnp=object[\"k\"]*sum(swi)+sum(!swi)\n\tAIC=2*object[\"Fit\"][\"logLikel\"]+2*np\n\tBIC=2*object[\"Fit\"][\"logLikel\"]+2*np*log(nrow(object@model$model))\n\tcat(\"\\n\")\n\tprint(data.frame(AIC = AIC, BIC = BIC, logLik = -object[\"Fit\"][\"logLikel\"],\n        row.names = \" \"))\n\n\tsw=apply(as.matrix(object@switch),1,function(x){\n\t\t\tif(x){\n\t\t\t\treturn(\"(S)\")\n\t\t\t}else{\n\t\t\t\treturn(\"\")\n\t\t\t}\n\t\t}\n\t)\n\ttau=as.matrix(object[\"Coef\"])\n\tdimnames(tau)=list(c(paste(rep(\"Model\",object[\"k\"]),as.character(c(1:object[\"k\"])))),c(paste(names(object[\"Coef\"]),sw,sep=\"\")))\n\tprint(tau)\n\tcat(\"\\nTransition probabilities:\\n\")\n\tprint(object[\"transMat\"])\n\treturn(invisible())\n}\nsetMethod(f=\"show\",signature=\"MSM.glm\",definition=.MSM.glm.show)\n\n\n\n##########\n##### summary\n\n.MSM.lm.summary=function(object){\n\tcat(\"Markov Switching Model\\n\")\n\tcat(\"\\nCall: \")\n\tprint(object[\"call\"])\n\tswi=object@switch[-length(object@switch)]\n\tnp=object[\"k\"]*sum(swi)+sum(!swi)\n\tAIC=2*object[\"Fit\"][\"logLikel\"]+2*np\n\tBIC=2*object[\"Fit\"][\"logLikel\"]+2*np*log(nrow(object@model$model))\n\tcat(\"\\n\")\n\tprint(data.frame(AIC = AIC, BIC = BIC, logLik = -object[\"Fit\"][\"logLikel\"],\n        row.names = \" \"))\n\tsw=apply(as.matrix(swi),1,function(x){\n\t\t\tif(x){\n\t\t\t\treturn(\"(S)\")\n\t\t\t}else{\n\t\t\t\treturn(\"\")\n\t\t\t}\n\t\t}\n\t)\n\tdigits=max(3, getOption(\"digits\") - 3)\n\t\tcat(\"\\nCoefficients:\\n\")\n\t\tfor(i in 1:object[\"k\"]){\n\t\t\tcat(\"\\nRegime\",i,\"\\n\")\n\t\t\tcat(\"---------\\n\")\n\t\t\test=t(round(object[\"Coef\"][i,],digits=digits))\n\t\t\tse=t(round(object[\"seCoef\"][i,],digits=digits))\n\t\t\tnval=round(est/se,digits=digits)\n\t\t\tcoefs=cbind(est,se,nval,apply(abs(nval),2,function(el) 2*(1-pnorm(abs(el)))))\n\t\t\tdimnames(coefs) <- list(paste(names(object[\"Coef\"]),sw,sep=\"\"), c(\"Estimate\", \"Std. Error\", \"t value\", \"Pr(>|t|)\"))\n\t\t\tprintCoefmat(coefs)\n\t\t\tf=object[\"Fit\"]@CondMean[,i]\n\t\t\tr=object[\"Fit\"]@error[,i]\n\t\t\tw=object[\"Fit\"]@smoProb[-1,i]\n      \t\tmss <- if (attr(object@model$terms, \"intercept\")) {\n            \t\tm <- sum(w * f/sum(w))\n            \t\tsum(w * (f - m)^2)\n        \t\t\t}\n\t\t           else sum(w * f^2)\n        \t\trss <- sum(w * r^2)\n\t\t\tr.squared <- mss/(mss + rss)\n\n\t\t\tcat(\"\\nResidual standard error:\",object[\"std\"][i])\n\t\t\tcat(\"\\n\")\n\t\t\tcat(\"Multiple R-squared:\", formatC(r.squared, digits = digits))\n\n\t\t\tresd <- r*sqrt(w)\n    \t\t\tif (length(resd) > 5) {\n\t\t        resd <- quantile(resd, na.rm = TRUE)\n\t\t        names(resd) <- c(\"Min\", \"Q1\", \"Med\", \"Q3\", \"Max\")\n    \t\t\t}\n \t\t\tcat(\"\\n\\nStandardized Residuals:\\n\")\n\t\t\tprint(resd)\n\t}\n\tcat(\"\\nTransition probabilities:\\n\")\n\tpro=object[\"transMat\"]\n\tdimnames(pro)=rep(list(paste(\"Regime\",1:object[\"k\"])),2)\n\tprint(pro)\n\n\treturn(invisible())\n}\nsetMethod(f=\"summary\",signature=\"MSM.lm\",definition=.MSM.lm.summary)\n\n.MSM.glm.summary=function(object){\n\tcat(\"Markov Switching Model\\n\")\n\tcat(\"\\nCall: \")\n\tprint(object[\"call\"])\n\tswi=object@switch\n\tnp=object[\"k\"]*sum(swi)+sum(!swi)\n\tAIC=2*object[\"Fit\"][\"logLikel\"]+2*np\n\tBIC=2*object[\"Fit\"][\"logLikel\"]+2*np*log(nrow(object@model$model))\n\tcat(\"\\n\")\n\tprint(data.frame(AIC = AIC, BIC = BIC, logLik = -object[\"Fit\"][\"logLikel\"],\n        row.names = \" \"))\n\tsw=apply(as.matrix(object@switch),1,function(x){\n\t\t\tif(x){\n\t\t\t\treturn(\"(S)\")\n\t\t\t}else{\n\t\t\t\treturn(\"\")\n\t\t\t}\n\t\t}\n\t)\n\tdigits=max(3, getOption(\"digits\") - 3)\n\t\tcat(\"\\nCoefficients:\\n\")\n\t\tfor(i in 1:object[\"k\"]){\n\t\t\tcat(\"\\nRegime\",i,\"\\n\")\n\t\t\tcat(\"---------\\n\")\n\t\t\test=t(round(object[\"Coef\"][i,],digits=digits))\n\t\t\tse=t(round(object[\"seCoef\"][i,],digits=digits))\n\t\t\tnval=round(est/se,digits=digits)\n\t\t\tcoefs=cbind(est,se,nval,apply(abs(nval),2,function(el) 2*(1-pnorm(abs(el)))))\n\t\t\tdimnames(coefs) <- list(paste(names(object[\"Coef\"]),sw,sep=\"\"), c(\"Estimate\", \"Std. Error\", \"t value\", \"Pr(>|t|)\"))\n\t\t\tprintCoefmat(coefs)\n\n\n\t}\n\tcat(\"\\nTransition probabilities:\\n\")\n\tpro=object[\"transMat\"]\n\tdimnames(pro)=rep(list(paste(\"Regime\",1:object[\"k\"])),2)\n\tprint(pro)\n\n\treturn(invisible())\n}\nsetMethod(f=\"summary\",signature=\"MSM.glm\",definition=.MSM.glm.summary)\n\n\n\n##########\n##### plot\n\n.MSM.plot=function(x,y,...){\n\tstate=apply(x[\"Fit\"][\"smoProb\"][-1,],1,order,decreasing=T)[1,]\n\tif((x[\"k\"]+1)>4){\n\t\taux=ifelse(!is.integer((x[\"k\"]+1)/2),1.15+0.15*(x[\"k\"]-4),1)\n\t}else{\n\t\taux=1\n\t}\n\tts.plot(x[\"Fit\"][\"error\"][,1],col=2,ylim=c(min(x[\"Fit\"][\"error\"])-0.5*aux*(abs(max(x[\"Fit\"][\"error\"]))+abs(min(x[\"Fit\"][\"error\"])))/2,max(x[\"Fit\"][\"error\"])),xlab=\"Order\",ylab=\"Residuals\")\n\tapply(as.matrix(2:x[\"k\"]),1,function(i) \tlines(x[\"Fit\"][\"error\"][,i],col=1+i))\n\tlines(apply(as.matrix(1:length(state)),1,function(i) x[\"Fit\"][\"error\"][i,state[i]]))\n\tabline(h=0)\n\tdata=x[\"Fit\"][\"error\"]\n\ttext=apply(as.matrix(1:x[\"k\"]),1,function(i){\n\t\t\tpaste(\"Regime \",i,sep=\"\")\n\t\t}\n\t)\n\ttext[length(text)+1]=\"Conditional\"\n\tcol=apply(as.matrix(1:x[\"k\"]),1,function(i){\n\t\t\ti+1\n\t\t}\n\t)\n\tcol[length(col)+1]=1\n\tlegend(dim(data)[1]*0.5,min(data)-0.1*abs(min(data)),legend=text,cex=0.8,col=col,lty=1,ncol=2)\n\treturn(invisible())\n}\nsetMethod(f=\"plot\",signature=c(\"MSM.linear\",\"missing\"),definition=.MSM.plot)\n\n\n##########\n##### plotProb\n\n.MSM.plotProb=function(x,which){\n\tif(missing(which)){\n\t\twhich=1:(x[\"k\"]+1)\n\t}else{\n\t\tif(is.numeric(which)){\n\t\t\tif(any(which > (x[\"k\"]+1))|any(which < 1)) stop(\"You must to write numbers between 1 and 3.\")\n\t\t}else{\n\t\t\tstop(\"You must write numbers.\")\n\t\t}\n\t}\n  oldpar=par()\n\ta=ceiling(x[\"k\"]/3)\n\taux1=1:a\n\taux2=matrix(NA,nrow=x[\"k\"],ncol=1)\n\taux2[,1]=apply(as.matrix(1:x[\"k\"]),1,function(i){\n\t\t\tif(any((aux1*3)==(i-1))){\n\t\t\t\tT\n\t\t\t}else{\n\t\t\t\tF\n\t\t\t}\n\t\t}\n\t)\n\taux2[1,1]=T\n\tcont=1\n\tif(any(which==1)){\n\t\tfor (i in 1:x[\"k\"]){\n\t\t\tif(aux2[i,1]){\n\t\t\t\tif(i>1){\n\t\t\t\t\tif(cont<length(aux1)){\n\t\t\t\t\t\tpar(omi=c(0.1,0.1,0.1,0.5))\n\t\t\t\t\t\tpar(mfrow=c(3,1))\n\t\t\t\t\t\tcont=cont+1\n\t\t\t\t\t}else{\n\t\t\t\t\t\tpar(omi=c(0.1,0.1,0.1,0.5))\n\t\t\t\t\t\tpar(mfrow=c(x[\"k\"]-(a-1)*3,1))\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(x[\"k\"]/3<1){\n\t\t\t\t\t\tpar(omi=c(0.1,0.1,0.1,0.5))\n\t\t\t\t\t\tpar(mfrow=c(2,1))\n\t\t\t\t\t}else{\n\t\t\t\t\t\tpar(omi=c(0.1,0.1,0.1,0.5))\n\t\t\t\t\t\tpar(mfrow=c(3,1))\n\t\t\t\t\t}\n\t\t\t\t\tcont=cont+1\n\t\t\t\t}\n\t\t\t}\n\t\t\tplot(x[\"Fit\"][\"filtProb\"][,i],main=paste(\"Regime\",i),ylim=c(0,1),xlab=\"\",ylab=\"\",type=\"h\")\n\t\t\tlines(x[\"Fit\"][\"smoProb\"][-1,i],col=2)\n\t\t\tpar(las=3)\n\t\t\tmtext(\"Smoothed Probabilities\",side=2,line=2.5,col=2)\n\t\t\tmtext(\"Filtered Probabilities\",side=4,line=2.5)\n\t\t}\n\t}\n\n\tif(any(which>1)){\n\t\taux=which[which>1]-1\n\t\tz=x[\"model\"]$model[1]\n\t\tapply(as.matrix(1:length(aux)),1,function(i){\n\t\t\t\ta=layout(matrix(c(1,1,1,2),ncol=1,nrow=4),TRUE)\n\t\t\t\ty=x[\"Fit\"][\"smoProb\"][-1,aux[i]]\n\t\t\t\tpar(omi=c(0.1,0.1,0.1,0.5))\n\t\t\t\tpar(las=1,yaxt=\"n\")\n\t\t\t\tplot(0,type=\"l\",xlim=c(1,length(t(z))),ylim=c(min(z),max(z)),main=paste(\"Regime\",aux[i]),xlab=paste(names(z),\"vs. Smooth Probabilities\"),ylab=\"\")\n\t\t\t\tval=cbind(which(diff(c(0,findInterval(y,0.5)))==1),which(diff(c(findInterval(y,0.5),0))==-1))\n\t\t\t\tapply(val,1,function(el) rect(el[1],min(z),el[2],max(z),col=\"light grey\",border=NA))\n\t\t\t\tpar(new=T,las=1,bty=\"o\",yaxt=\"n\")\n\t\t\t\tplot(ts(z),col=1,ylim=c(min(z),max(z)),xlab=\"\",ylab=\"\")\n\t\t\t\tpar(las=3,yaxt=\"s\")\n\t\t\t\tmtext(names(z),side=2,line=2.5,col=1)\n\t\t\t\taxis(side=4)\n\t\t\t\tbarplot(x[\"Fit\"][\"smoProb\"][-1,aux[i]],ylim=c(0,1))\n\t\t\t}\n\t\t)\n\t}\n  par(mfrow=c(1,1))\n\treturn(invisible())\n}\nsetMethod(f=\"plotProb\",signature=c(\"MSM.linear\",\"ANY\"),definition=.MSM.plotProb)\n\n\n\n##########\n##### plotReg\n\n.MSM.larg.plotReg=function(x,expl,regime){\n\tif(missing(regime)){\n\t\tregime=1\n\t}else{\n\t\tif(is.numeric(regime)){\n\t\t\tif(any(regime > x[\"k\"])|any(regime < 1)) stop(\"You must to write a correct regime.\")\n\t\t}else{\n\t\t\tstop(\"regime must to be numeric.\")\n\t\t}\n\t}\n\tz=x[\"model\"]$model[1]\n\tapply(as.matrix(1:length(regime)),1,function(j){\n\t\tapply(as.matrix(1:length(x[\"model\"]$model[-1])),1,function(i){\n\t\t\t\ta=layout(matrix(c(1,2,1,2),ncol=1,nrow=2),TRUE)\n\t\t\t\ty=x[\"Fit\"][\"smoProb\"][-1,regime[j]]\n\t\t\t\tv=x[\"model\"]$model[i+1]\n\t\t\t\tpar(omi=c(0.1,0.01,0.1,0.1))\n\t\t\t\tpar(las=1)\n\t\t\t\tplot(0,type=\"l\",xlim=c(1,length(t(z))),ylim=c(min(z),max(z)),main=paste(\"Regime\",regime[j],sep=\"\"),xlab=paste(names(z),\"with Smooth Probabilities\"),ylab=\"\")\n\t\t\t\tval=cbind(which(diff(c(0,findInterval(y,0.5)))==1),which(diff(c(findInterval(y,0.5),0))==-1))\n\t\t\t\tapply(val,1,function(el) rect(el[1],min(z),el[2],max(z),col=\"light grey\",border=NA))\n\t\t\t\tpar(new=T,las=1,bty=\"o\")\n\t\t\t\tplot(ts(z),col=1,ylim=c(min(z),max(z)),main=\"\",xlab=\"\",ylab=\"\")\n\t\t\t\tplot(0,type=\"l\",xlim=c(1,length(t(v))),ylim=c(min(v),max(v)),main=\"\",xlab=paste(names(v),\"with Smooth Probabilities\"),ylab=\"\")\n\t\t\t\tapply(val,1,function(el) rect(el[1],min(v),el[2],max(v),col=\"light grey\",border=NA))\n\t\t\t\tpar(new=T,las=1,bty=\"o\")\n\t\t\t\tplot(ts(v),col=1,ylim=c(min(v),max(v)),main=\"\",xlab=\"\",ylab=\"\")\n\t\t\t}\n\t\t\t)\n\t\t}\n\t)\n\tpar(mfrow=c(1,1))\n\treturn(invisible())\n}\nsetMethod(f=\"plotReg\",signature=c(\"MSM.linear\",\"missing\",\"ANY\"),definition=.MSM.larg.plotReg)\n\n\n.MSM.sma.plotReg=function(x,expl,regime){\n\tapply(as.matrix(expl),1,function(var) if(!any(apply(as.matrix(names(x[\"model\"]$model[-1])),1,function(el) ifelse(var==el,T,F)))) stop(\"The name of the variable is not correct.\\n\"))\n\tif(missing(regime)){\n\t\tregime=1\n\t}else{\n\t\tif(is.numeric(regime)){\n\t\t\tif(any(regime > x[\"k\"])|any(regime < 1)) stop(\"You must to write a correct regime.\")\n\t\t}else{\n\t\t\tstop(\"regime must to be numeric.\")\n\t\t}\n\t}\n\tz=x[\"model\"]$model[1]\n\tapply(as.matrix(1:length(regime)),1,function(j){\n\t\tapply(as.matrix(1:length(expl)),1,function(i){\n\t\t\t\ta=layout(matrix(c(1,2,1,2),ncol=1,nrow=2),TRUE)\n\t\t\t\ty=x[\"Fit\"][\"smoProb\"][-1,regime[j]]\n\t\t\t\tv=x[\"model\"]$model[expl[i]]\n\t\t\t\tpar(omi=c(0.1,0.1,0.1,0.1))\n\t\t\t\tpar(las=1,yaxt=\"n\")\n\t\t\t\tplot(0,type=\"l\",xlim=c(1,length(t(z))),ylim=c(min(z),max(z)),main=paste(\"Regime\",regime[j],sep=\"\"),xlab=paste(names(z),\"with Smooth Probabilities\"),ylab=\"\")\n\t\t\t\tval=cbind(which(diff(c(0,findInterval(y,0.5)))==1),which(diff(c(findInterval(y,0.5),0))==-1))\n\t\t\t\tapply(val,1,function(el) rect(el[1],min(z),el[2],max(z),col=\"light grey\",border=NA))\n\t\t\t\tpar(new=T,las=1,bty=\"o\",yaxt=\"n\")\n\t\t\t\tplot(ts(z),col=1,ylim=c(min(z),max(z)),main=\"\",xlab=\"\",ylab=\"\")\n\t\t\t\tplot(0,type=\"l\",xlim=c(1,length(t(v))),ylim=c(min(v),max(v)),main=\"\",xlab=paste(names(v),\"with Smooth Probabilities\"),ylab=\"\")\n\t\t\t\tapply(val,1,function(el) rect(el[1],min(v),el[2],max(v),col=\"light grey\",border=NA))\n\t\t\t\tpar(new=T,las=1,bty=\"o\",yaxt=\"n\")\n\t\t\t\tplot(ts(v),col=1,ylim=c(min(v),max(v)),main=\"\",xlab=\"\",ylab=\"\")\n\t\t\t}\n\t\t\t)\n\t\t}\n\t)\n\tpar(mfrow=c(1,1))\n\treturn(invisible())\n}\nsetMethod(f=\"plotReg\",signature=c(\"MSM.linear\",\"character\",\"ANY\"),definition=.MSM.sma.plotReg)\n\n##########\n##### plotDiag\n\n.MSM.larg.plotDiag=function(x,regime,which){\n\tif(missing(which)){\n\t\twhich=1:3\n\t}else{\n\t\tif(is.numeric(which)){\n\t\t\tif(any(which > 3)|any(which < 1)) stop(\"You must to write numbers between 1 and 3.\")\n\t\t}else{\n\t\t\tstop(\"You must write numbers.\")\n\t\t}\n\t}\n\tresidPooled=apply(x[\"Fit\"][\"error\"]*x[\"Fit\"][\"smoProb\"][-1,],1,sum)\n\tif(any(which==1)){\n\t\tts.plot(residPooled,main=\"Pooled residuals\")\n\t\tabline(h=0)\n\t\tabline(h=c(-3*sd(residPooled),3*sd(residPooled)),lty=3,col=4)\n\t}\n\tif(any(which==2)){\n\t\tqqnorm(residPooled,main=\"Normal Q-Q Plot Pooled Residuals\")\n\t\tqqline(residPooled,col=2,lwd=2)\n\t}\n\tif(any(which==3)){\n\t\tpar(mfrow=c(2,2))\n\t\tacf(residPooled,ylim=c(-1,1),main=\"ACF of Residuals\")\n\t\tpacf(residPooled,ylim=c(-1,1),main=\"PACF of Residuals\")\n\t\tacf(residPooled^2,ylim=c(-1,1),main=\"ACF of Square Residuals\")\n\t\tpacf(residPooled^2,ylim=c(-1,1),main=\"PACF of Square Residuals\")\n\t\tpar(mfrow=c(1,1))\n\t}\n\treturn(invisible())\n}\nsetMethod(f=\"plotDiag\",signature=c(\"MSM.linear\",\"missing\",\"ANY\"),definition=.MSM.larg.plotDiag)\n\n.MSM.larg.plotDiag=function(x,regime,which){\n\tif(regime[length(regime)]==\"all\"){\n\t\taux=c(1:x[\"k\"])\n\t}else{\n\t\tif(any(regime > x[\"k\"])|any(regime < 1)) stop(\"You must to write a correct regime.\")\n\t\taux=regime\n\t}\n\tif(missing(which)){\n\t\twhich=1:3\n\t}else{\n\t\tif(is.numeric(which)){\n\t\t\tif(any(which > 3)|any(which < 1)) stop(\"You must to write numbers between 1 and 3.\")\n\t\t}else{\n\t\t\tstop(\"You must write numbers.\")\n\t\t}\n\t}\n\tapply(as.matrix(aux),1,function(i){\n\t\t\tif(any(which==1)){\n\t\t\t\tts.plot(x[\"Fit\"][\"error\"][,i],main=paste(\"Regime \",i,sep=\"\"),ylab=\"Residuals\")\n\t\t\t\tabline(h=0)\n\t\t\t\tabline(h=c(-3*sd(x[\"Fit\"][\"error\"][,i]),3*sd(x[\"Fit\"][\"error\"][,i])),lty=3,col=4)\n\t\t\t}\n\t\t\tif(any(which==2)){\n\t\t\t\tqqnorm(x[\"Fit\"][\"error\"][,i],main=paste(\"Normal Q-Q Plot Regime \",i,sep=\"\"))\n\t\t\t\tqqline(x[\"Fit\"][\"error\"][,i],col=2,lwd=2)\n\t\t\t}\n\t\t\tif(any(which==3)){\n\t\t\t\tpar(mfrow=c(2,2))\n\t\t\t\tacf(x[\"Fit\"][\"error\"][,i],ylim=c(-1,1),main=paste(\"ACF of Residuals. Reg: \",i,sep=\"\"))\n\t\t\t\tpacf(x[\"Fit\"][\"error\"][,i],ylim=c(-1,1),main=paste(\"PACF of Residuals. Reg: \",i,sep=\"\"))\n\t\t\t\tacf(x[\"Fit\"][\"error\"][,i]^2,ylim=c(-1,1),main=paste(\"ACF of Square Resid. Reg: \",i,sep=\"\"))\n\t\t\t\tpacf(x[\"Fit\"][\"error\"][,i]^2,ylim=c(-1,1),main=paste(\"PACF of Square Resid. Reg: \",i,sep=\"\"))\n\t\t\t\tpar(mfrow=c(1,1))\n\t\t\t}\n\t\t}\n\t)\n\treturn(invisible())\n}\nsetMethod(f=\"plotDiag\",signature=c(\"MSM.linear\",\"ANY\",\"ANY\"),definition=.MSM.larg.plotDiag)\n\n\n\n##########\n##### resid\n.MSM.lm.sma.msmResid=function(object,regime){\n\treturn(apply(object[\"Fit\"][\"error\"]*object[\"Fit\"][\"smoProb\"][-1,],1,sum))\n}\nsetMethod(f=\"msmResid\",signature=c(\"MSM.lm\",\"missing\"),definition=.MSM.lm.sma.msmResid)\n\n.MSM.lm.larg.msmResid=function(object,regime){\n\tif(regime[length(regime)]==\"all\"){\n\t\taux=c(1:object[\"k\"])\n\t\tres=apply(as.matrix(aux),1,function(i) object[\"Fit\"][\"error\"][,i])\n\t\tdimnames(res)[[2]]=paste(\"Regime \",1:object[\"k\"],sep=\"\")\n\t\treturn(res)\n\t}else{\n\t\tif(any(regime > object[\"k\"])|any(regime < 1)) stop(\"You must to write a correct regime.\")\n\t\taux=regime\n\t\treturn(object[\"Fit\"][\"error\"][,regime])\n\t\t}\n}\nsetMethod(f=\"msmResid\",signature=c(\"MSM.lm\",\"ANY\"),definition=.MSM.lm.larg.msmResid)\n\n# .MSM.glm.sma.msmResid=function(object,regime){\n# \tres=object[\"Fit\"][\"error\"]/sqrt(object@family$variance(object[\"Fit\"]@CondMean))\n# \treturn(apply(res*object[\"Fit\"][\"smoProb\"][-1,],1,sum))\n# }\n# setMethod(f=\"msmResid\",signature=c(\"MSM.glm\",\"missing\"),definition=.MSM.glm.sma.msmResid)\n#\n# .MSM.glm.larg.msmResid=function(object,regime){\n# \tif(regime[length(regime)]==\"all\"){\n# \t\taux=c(1:object[\"k\"])\n# \t\tres=apply(as.matrix(aux),1,function(i) object[\"Fit\"][\"error\"][,i]/sqrt(object@family$variance(object[\"Fit\"]@CondMean[,i])))\n# \t\tdimnames(res)[[2]]=paste(\"Regime \",1:object[\"k\"],sep=\"\")\n# \t\treturn(res)\n# \t}else{\n# \t\tif(any(regime > object[\"k\"])|any(regime < 1)) stop(\"You must to write a correct regime.\")\n# \t\taux=regime\n# \t\treturn(object[\"Fit\"][\"error\"][,regime]/sqrt(object@family$variance(object[\"Fit\"]@CondMean[,regime])))\n# \t\t}\n# }\n# setMethod(f=\"msmResid\",signature=c(\"MSM.glm\",\"ANY\"),definition=.MSM.glm.larg.msmResid)\n\n\nAIC.MSM.lm <-\n\n  function(object, ..., k=2)\n{\n\tswi=object@switch\n\tnp=object[\"k\"]*sum(swi)+sum(!swi)\n\treturn(2*object[\"Fit\"][\"logLikel\"]+k*np)\n  }\n\nAIC.MSM.glm <-\n\n  function(object, ..., k=2)\n{\n\tswi=object@switch\n\tnp=object[\"k\"]*sum(swi)+sum(!swi)\n\treturn(2*object[\"Fit\"][\"logLikel\"]+k*np)\n}\n\nAIC <-\n  ## Return the object's value of the Bayesian Information Criterion\n  function(object, ...,k=2) UseMethod(\"AIC\")\n\nintervals.MSM.lm=function(object,level=0.95,...){\n\tcat(\"\\nAproximate intervals for the coefficients. Level=\",level,\"\\n\")\n\taux=names(object[\"Coef\"])\n\tlower=object[\"Coef\"]-qnorm(1-(1-level)/2)*object[\"seCoef\"]\n\tupper=object[\"Coef\"]+qnorm(1-(1-level)/2)*object[\"seCoef\"]\n\ta=apply(as.matrix(1:length(aux)),1,function(i){\n\t\t\tcat(paste(\"\\n\",aux[i],\": \\n\",sep=\"\"))\n\t\t\t#cat(\"---------\\n\")\n\t\t\tintmat=cbind(lower[aux[i]],object[\"Coef\"][aux[i]],upper[aux[i]])\n\t\t\tdimnames(intmat)=list(c(paste(\"Regime \",1:object[\"k\"],sep=\"\")),c(\"Lower\",\"Estimation\",\"Upper\"))\n\t\t\tprint(intmat)\n\t\t\t#cat(\"---------\\n\")\n\t\t\tcat(\"\\n\")\n\t\t}\n\t)\n}\nintervals.MSM.glm=function(object,level=0.95,...){\n\tcat(\"\\nAproximate intervals for the coefficients. Level=\",level,\"\\n\")\n\taux=names(object[\"Coef\"])\n\tlower=object[\"Coef\"]-qnorm(1-(1-level)/2)*object[\"seCoef\"]\n\tupper=object[\"Coef\"]+qnorm(1-(1-level)/2)*object[\"seCoef\"]\n\ta=apply(as.matrix(1:length(aux)),1,function(i){\n\t\t\tcat(paste(\"\\n\",aux[i],\": \\n\",sep=\"\"))\n\t\t\t#cat(\"---------\\n\")\n\t\t\tintmat=cbind(lower[aux[i]],object[\"Coef\"][aux[i]],upper[aux[i]])\n\t\t\tdimnames(intmat)=list(c(paste(\"Regime \",1:object[\"k\"],sep=\"\")),c(\"Lower\",\"Estimation\",\"Upper\"))\n\t\t\tprint(intmat)\n\t\t\t#cat(\"---------\\n\")\n\t\t\tcat(\"\\n\")\n\t\t}\n\t)\n}\nintervals <-\n  ## Return the object's value of the Bayesian Information Criterion\n  function(object,level=0.95,...) UseMethod(\"intervals\")\n\n\n#########\n#### msmfilter\n\n.MSM.lm.msmFilter= function(object){\n\tmodel=object[\"model\"]\n\tk=object[\"k\"]\n\n\tCoef=object[\"Coef\"]\n\tstd=object[\"std\"]\n\tP=object[\"transMat\"]\n\n\t# Calculation of some preliminar variables\n\tnr=length(model$model[,1])\n\tterms=model.matrix(model)\n\n\tCondMean=as.matrix(terms)%*%t(as.matrix(Coef))\n\terror= as.matrix(model$model[,1,drop=F])%*%matrix(rep(1,k),nrow=1)-CondMean\n\tLikel=t(dnorm(t(error),0,std))\n\n\t###Filtered Probabilities ####\n\tfProb=matrix(data=0,nrow=nr,ncol=k)\n\tmargLik=matrix(data=0,nrow=nr,ncol=1)\n\n\tfProb[1,]= (P%*%matrix(object[\"iniProb\"],ncol=1))*t(Likel[1,,drop=F])\n\tmargLik[1,1] = sum(fProb[1,])\n\tfProb[1,] = fProb[1,] / margLik[1,1]\n\tfor (i in 2:nr){\n\t\t# Mixtura de funcions\n\t\t# MS filter equation\n\t\t# MS filter Filter margLikuation for probabilities\n\t\tfProb[i,] = (P%*%t(fProb[i-1,,drop=F]))*t(Likel[i,,drop=F])\n\t\tmargLik[i,1] = sum(fProb[i,])\n\t\tfProb[i,] = fProb[i,]/margLik[i,1]\n\t}\n\n\t# Negative sum of log Likelihood\n\tloglik=-sum(log(margLik[1:nr]))\n\n\t# Passing up to output structure\n\tans=new(Class=\"MSM.fitted\",CondMean=CondMean,error=error, Likel=Likel,margLik=margLik, filtProb=fProb, logLikel=loglik )\n\treturn(ans)\n}\nsetMethod(f=\"msmFilter\",signature=c(\"MSM.lm\"),definition=.MSM.lm.msmFilter)\n\n.MSM.glm.msmFilter=function(object){\n\tmodel=object[\"model\"]\n\tk=object[\"k\"]\n\tfamily=model$family\n\n\tCoef=object[\"Coef\"]\n\tP=object[\"transMat\"]\n\n\t# Calculation of some preliminar variables\n\tnr=length(model$model[,1])\n\n\tterms=model.matrix(model)\n\n\tCondMean=family$linkinv(as.matrix(terms)%*%t(as.matrix(Coef)))\n\terror= as.matrix(model$model[,1,drop=F])%*%matrix(rep(1,k),nrow=1)-CondMean\n\n\tLikel=object@Likelihood(as.matrix(model$model[,1,drop=F])%*%matrix(rep(1,k),nrow=1),mu=CondMean)\n\n\t###Filtered Probabilities ####\n\tfProb=matrix(data=0,nrow=nr,ncol=k)\n\tmargLik=matrix(data=0,nrow=nr,ncol=1)\n\n\tmargLik[1,1]=sum ((P%*%matrix(object[\"iniProb\"],ncol=1)) * t(Likel[1,,drop=F]))\n\tfProb[1,]= ((P%*%matrix(object[\"iniProb\"],ncol=1))*t(Likel[1,,drop=F]))/margLik[1,1]\n\tfor (i in 2:nr){\n\t\t# Mixtura de funcions\n\t\t# MS filter margLikuation\n\t\tmargLik[i,1]=sum ((P%*%t(fProb[i-1,,drop=F])) * t(Likel[i,,drop=F]))\n\t\t# MS filter Filter margLikuation for probabilities\n\t\tfProb[i,]= ((P%*%t(fProb[i-1,,drop=F])*t(Likel[i,,drop=F]))/margLik[i,1])\n\t}\n\n\t# Negative sum of log Likelihood for fmincon (fmincon minimzes the function)\n\tloglik=-sum(log(margLik[1:nr]))\n\n\t# Passing up to output structure\n\tans=new(Class=\"MSM.fitted\",CondMean=CondMean,error=error, Likel=Likel,margLik=margLik, filtProb=fProb, logLikel=loglik )\n\treturn(ans)\n}\nsetMethod(f=\"msmFilter\",signature=c(\"MSM.glm\"),definition=.MSM.glm.msmFilter)\n\n#########\n#### msmsmooth\n\n.MSM.msmSmooth=function(object){\n\tobject@Fit=msmFilter(object)\n\tnr=length(object[\"model\"]$model[,1])\n\tfProb=object[\"Fit\"][\"filtProb\"]\n\tk=object[\"k\"]\n\tP=object[\"transMat\"]\n\tsmoTransMatrob=matrix(0,ncol=k,nrow=nr+1)\n\tsmoTransMatrob[nr+1,]=fProb[nr,]\n\t#smoTransMatrob[nr+1,]=fProb[nr,]%*%t(P)\n\n\tproba=rbind(object@iniProb,fProb)\n\tpro=proba%*%t(P)\n\tsmoTransMat=list(NULL)\n\tfor (i in (nr-1):0){\n\t\tsmoTransMat[[i+1]]=matrix(0,ncol=k,nrow=k)\n\t\tfor (ini in 1:k){\n\t\t\tsmoTransMatrob[i+1,ini]=0\n\t\t\tfor (fi in 1:k){\n\t\t\t\tsmoTransMat[[i+1]][ini,fi]=smoTransMatrob[i+2,fi]*proba[i+1,ini]*P[fi,ini]/pro[i+1,fi]\n\t\t\t\tsmoTransMatrob[i+1,ini]=smoTransMatrob[i+1,ini] + smoTransMat[[i+1]][ini,fi]\n\t\t\t}\n\t\t}\n\t}\n\tobject@Fit@smoProb=smoTransMatrob\n\tobject@Fit@smoTransMat=smoTransMat\n\treturn(object)\n}\nsetMethod(f=\"msmSmooth\",signature=c(\"MSM.linear\"),definition=.MSM.msmSmooth)\n\n\n#########\n####optimizer\nfopt.lm=function(param, object=object){\n\tif (tail(object[\"switch\"],1)==F){\n\t\tobject@std<-exp(param[1])\n\t\tini=1\n\t} else {\n\t\tobject@std<-exp(param[1:object[\"k\"]])\n\t\tini=object[\"k\"]\n \t}\n\tlong=ini+(object[\"k\"]-1)*object[\"k\"]\n\tmprob=matrix(logitinv(c(param[(ini+1):long])),nrow=object[\"k\"],byrow=T)\n\tobject@transMat<-matrix(c(mprob,1-apply(mprob,1, function(x) sum(x))),nrow=object[\"k\"],byrow=T)\n\tswi=object[\"switch\"][-length(object[\"switch\"])]\n\tmi=sum(!swi)\n\taux=object[\"Coef\"]\n\taux[,which(swi)]=as.data.frame(matrix(param[-c(1:(long+mi))],nrow=object[\"k\"],byrow=T))\n\taux[,which(!swi)]=as.data.frame(matrix(rep(param[long+(1:mi)],object[\"k\"]),nrow=object[\"k\"],byrow=T))\n\tobject@Coef=aux\n\treturn(msmFilter(object)@logLikel)\n}\n\n# fopt.glm=function(param, object=object){\n# \tlong=(object[\"k\"]-1)*object[\"k\"]\n# \tmprob=matrix(logitinv(c(param[1:long])),ncol=object[\"k\"],byrow=T)\n# \tobject@transMat<-matrix(c(mprob,1-apply(mprob,2, function(x) sum(x))),nrow=object[\"k\"],byrow=T)\n# \tswi=object[\"switch\"]\n# \tmi=sum(!swi)\n# \taux=object[\"Coef\"]\n# \taux[,which(swi)]=as.data.frame(matrix(param[-c(1:(long+mi))],nrow=object[\"k\"],byrow=T))\n# \taux[,which(!swi)]=as.data.frame(matrix(rep(param[long+(1:mi)],object[\"k\"]),nrow=object[\"k\"],byrow=T))\n# \tobject@Coef=aux\n# \treturn(msmFilter(object)@logLikel)\n# }\n\n\n.MSM.lm.hessian=function(object){\n\t\tif (tail(object[\"switch\"],1)==F){\n\t\t\tlstd=log(object[\"std\"][1])\n\t\t} else {\n\t\t\tlstd=log(object[\"std\"])\n\t \t}\n\t\tswi=object[\"switch\"][-length(object[\"switch\"])]\n   \t\tparam=c(lstd,\n\t\tlogit(matrix(object[\"transMat\"][1:object[\"k\"]-1,],nrow=1,byrow=T)),\n\t\tobject[\"Coef\"][1,!swi],\n\t\tmatrix(t(as.matrix(object[\"Coef\"])[,swi]),nrow=1))\n\t\tres=fdHess(\n\t\t\tpars=param,\n\t\t\tfun=fopt.lm,\n\t\t\tobject=object\n\t\t)\n\n\t\t# non-switching variance will have only one value\n\t\t# long=object[\"k\"]+(object[\"k\"]-1)*object[\"k\"]\n\t\tlong=length(lstd)+(object[\"k\"]-1)*object[\"k\"]\n\t\tmi=sum(!swi)\n\n\t\t# use Ginv(), the generalized inversed for singular matrix\n\t\t# hessian=sqrt(abs(diag(solve(res$Hessian))))\n\t\t# if(class(try(solve(res$Hessian), silent=TRUE))==\"try-error\"){\n\t\t#   hessian=sqrt(abs(diag(Ginv(res$Hessian))))\n\t\t# }else{\n\t\t#   hessian=sqrt(abs(diag(solve(res$Hessian))))\n\t\t# }\n\n\t\thessian=sqrt(abs(diag(Ginv(res$Hessian))))\n\n\t\tstdaux=object[\"Coef\"]\n    stdaux[,which(swi)]=as.data.frame(matrix(hessian[-c(1:(long+mi))],nrow=object[\"k\"],byrow=T))\n    stdaux[,which(!swi)]=as.data.frame(matrix(rep(hessian[long+(1:mi)],object[\"k\"]),nrow=object[\"k\"],byrow=T))\n\t\tobject@seCoef=stdaux\n\t\treturn(object)\n}\nsetMethod(f=\"hessian\",signature=c(\"MSM.lm\"),definition=.MSM.lm.hessian)\n\n\n.MSM.glm.hessian=function(object){\n    \t\tparam=c(\n\t\tlogit(matrix(object[\"transMat\"][1:object[\"k\"]-1,],nrow=1,byrow=T)),\n\t\tas.matrix(object[\"Coef\"])[1,!object[\"switch\"]],\n\t\tmatrix(t(as.matrix(object[\"Coef\"])[,object[\"switch\"]]),nrow=1))\n\t\tres=fdHess(\n\t\t\tpars=param,\n\t\t\tfun=fopt.glm,\n\t\t\tobject=object\n\t\t)\n\t\tlong=(object[\"k\"]-1)*object[\"k\"]\n\t\tmi=sum(!object[\"switch\"])\n\t      hessian=sqrt(abs(diag(solve(res$Hessian))))\n\t\tstdaux=object[\"Coef\"]\n\t\tstdaux[,which(object[\"switch\"])]=as.data.frame(matrix(hessian[-c(1:(long+mi))],nrow=object[\"k\"],byrow=T))\n\t\tstdaux[,which(!object[\"switch\"])]=as.data.frame(matrix(rep(hessian[long+(1:mi)],object[\"k\"]),nrow=object[\"k\"],byrow=T))\n\t\tobject@seCoef=stdaux\n\t\treturn(object)\n}\nsetMethod(f=\"hessian\",signature=c(\"MSM.glm\"),definition=.MSM.glm.hessian)\n\n.MSM.lm.maximEM=function(object,dades){\n \tk=object[\"k\"]\n\tswi=object[\"switch\"][-length(object[\"switch\"])]\n\tco=object[\"Coef\"]\n\tw=object[\"Fit\"][\"smoProb\"][-1,]\n\n\tmodaux=lm(y~.-1,dades,weights=c(t(w)))\n\tobject@Coef=as.data.frame(matrix(rep(coef(modaux),rep(ifelse(swi,1,k),ifelse(swi,k,1))),nrow=k))\n\tif (tail(object[\"switch\"],1)==T){\n\t\tobject@std=sqrt(apply(w*matrix(resid(modaux),ncol=k,byrow=T)^2,2,sum)/apply(w,2,sum))\n\t} else {\n\t\tstd=sum(weighted.residuals(modaux)^2)/nrow(w)\n\t\tobject@std=rep(sqrt(std),k)\n\t}\n\tnames(object@Coef)=names(co)\n\treturn(object)\n}\n\nsetMethod(f=\"maximEM\",signature=c(\"MSM.lm\",\"data.frame\"),definition=.MSM.lm.maximEM)\n\n.MSM.glm.maximEM=function(object,dades){\n \tk=object[\"k\"]\n\tsw=object[\"switch\"]\n\tco=object[\"Coef\"]\n\tw=object[\"Fit\"][\"smoProb\"][-1,]\n\n\tmodaux=glm(y~.-1,dades,weights=c(t(w)),family=object[\"model\"]$family)\n\n\tobject@Coef=as.data.frame(matrix(rep(coef(modaux),rep(ifelse(sw,1,k),ifelse(sw,k,1))),nrow=k))\n\tnames(object@Coef)=names(co)\n\treturn(object)\n\n}\nsetMethod(f=\"maximEM\",signature=c(\"MSM.glm\",\"data.frame\"),definition=.MSM.glm.maximEM)\n\n\n.MSM.linear.iteraEM=function(object,dades,control){\n\tk=object[\"k\"]\n\tfor (it in 1:control$maxiter){\n\t\toldcoef=object[\"Coef\"]\n\t\toldll=object[\"Fit\"][\"logLikel\"]\n\n\t\t##M-step\n\t\tobject=maximEM(object,dades)\n\t\tsmoTransMatrob=object[\"Fit\"][\"smoProb\"]\n\t\tsmoTransMat=object[\"Fit\"][\"smoTransMat\"]\n\t\tobject@transMat=matrix(apply(matrix(unlist(smoTransMat),nrow=k*k),1,sum)/rep(apply(smoTransMatrob[-1,],2,sum),rep(k,k)),ncol=k)\n\t\tobject@iniProb=object[\"Fit\"][\"smoProb\"][1,]\n\n\t\t##E-step\n\t\tobject=msmSmooth(object)\n\n\t\tif (control$trace) cat(\" Inner Iter.\",it,\" logLikel=\",object[\"Fit\"][\"logLikel\"],\"\\n\")\n\t\tif ((max(abs(object[\"Fit\"][\"logLikel\"] - oldll))/(0.1 + max(abs(object[\"Fit\"][\"logLikel\"]))) < control$tol)& (max(abs(object[\"Coef\"] - oldcoef))/(0.1 + max(abs(object[\"Coef\"]))) < control$tol)) break\n\t}\n\treturn(object)\n}\nsetMethod(f=\"iteraEM\",signature=c(\"MSM.linear\",\"data.frame\",\"ANY\"),definition=.MSM.linear.iteraEM)\n\n\n\n####em\n.MSM.em=function(object,control){\n\n  \t\tk=object[\"k\"]\n\t\tswi=object[\"switch\"]\n\t\tco=object[\"Coef\"]\n\n\t\tconstX=function(el,swit){\n\t\t\tif(swit){ mat=diag(1,k) }else{ mat=rep(1,k)}\n\t\t\tkronecker(el,mat)\n\t\t}\n\t\tXini=model.matrix(object[\"model\"])\n\t\tX=NULL\n\t\tfor(i in 1:ncol(Xini)){ X=cbind(X,constX(Xini[,i,drop=F],swi[i])) }\n\t\ty=kronecker(as.matrix(object[\"model\"]$model[,1,drop=F]),rep(1,k))\n\t\tdades=data.frame(y=y,X)\n\n\t\tmprob=object@transMat[-1,,drop=F]\n\t\tobject@transMat=matrix(c(1-apply(mprob,2, function(x) sum(x)),mprob),nrow=object[\"k\"],byrow=T)\n\t\tobject@transMat[object@transMat<0]=0\n\t\tobject@transMat[object@transMat>1]=1\n\t\tobject=msmSmooth(object)\n\n\t\tmaxiterInner=control$maxiterInner\n\t\tmaxiterOuter=control$maxiterOuter\n\t\tparallelization=control$parallelization\n\n  \tif(parallelization){\n  \t\t    mc=detectCores(logical = TRUE)\n  \t\t    cl <- makeCluster(mc)\n  \t\t    #clusterExport(cl,c(\"dades\",\"object\",\"control\",\"maxiterInner\"))\n  \t}\n\n\t\tparalel=function(id){\n\t\t\tx<-object\n\t\t\tsmoTransMat=lapply(vector(\"list\",nrow(x@Fit@filtProb)),function(el){\n\t\t\t\t\tma=runif(k*k)\n\t\t\t   \t \tmatrix(ma/sum(ma),ncol=k)\n\t\t\t\t})\n\t\t\tsmoTransMatrob=rbind(t(sapply(smoTransMat,function(el)apply(el,1,sum))),runif(k))\n\n\t\t\tx@Fit@smoTransMat<-smoTransMat\n\t\t\tx@Fit@smoProb=smoTransMatrob\n\t\t\tx=iteraEM(x,dades,control=list(maxiter=maxiterInner,tol=control$tol,trace=control$trace,parallelization=control$parallelization))\n\t\t\treturn(list(Minim=x@Fit@logLikel,inismoTransMat=x@Fit@smoTransMat,inismoTransMatrob=x@Fit@smoProb))\n\t\t}\n  \tif(parallelization){\n  \t      junk <- clusterEvalQ(cl, library(MSwM))\n\t\t\t\t\tparalRes=parLapply(cl, c(1:maxiterOuter),paralel)\n          stopCluster(cl)\n  \t\t  } else {\n  \t\t    paralRes=lapply(c(1:maxiterOuter),paralel)\n  \t\t  }\n\n\n\n\t\tMinim=paralRes[[1]][[\"Minim\"]]\n\t\tinismoTransMat=paralRes[[1]][[\"inismoTransMat\"]]\n\t\tinismoTransMatrob=paralRes[[1]][[\"inismoTransMatrob\"]]\n\t\ti=2\n\t\twhile(i<=maxiterOuter){\n\t\t\tif(Minim>paralRes[[i]][[\"Minim\"]]){\n\t\t\t\tMinim=paralRes[[i]][[\"Minim\"]]\n\t\t\t\tinismoTransMat=paralRes[[i]][[\"inismoTransMat\"]]\n\t\t\t\tinismoTransMatrob=paralRes[[i]][[\"inismoTransMatrob\"]]\n\t\t\t}\n\t\t\ti=i+1\n\t\t}\n\n\t\tif (control$trace) cat(\"Initial Value:\",Minim,\"\\n\")\n  \t\tobject@Fit@smoTransMat=inismoTransMat\n  \t\tobject@Fit@smoProb=inismoTransMatrob\n\t\tobject=iteraEM(object,dades,control)\n\t\tif (control$trace) cat(\"Calculating standard errors...\\n\")\n\t\tobject=hessian(object)\n\t\treturn(object)\n\n}\nsetMethod(f=\"em\",signature=c(\"MSM.linear\",\"list\"),definition=.MSM.em)\n\n\n",
    "created" : 1488894559260.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "24554986",
    "id" : "4507FA05",
    "lastKnownWriteTime" : 1488896412,
    "last_content_update" : 1488896412201,
    "path" : "C:/Users/EARAEAM/Desktop/MT/MSwM2/R/2MSM.r",
    "project_path" : "R/2MSM.r",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}