smoTransMat=lapply(vector("list",nrow(x@Fit@filtProb)),function(el){
ma=runif(k*k)
matrix(ma/sum(ma),ncol=k)
})
smoTransMatrob=rbind(t(sapply(smoTransMat,function(el)apply(el,1,sum))),runif(k))
x@Fit@smoTransMat<-smoTransMat
x@Fit@smoProb=smoTransMatrob
x=iteraEM(x,dades,control=list(maxiter=maxiterInner,tol=control$tol,trace=control$trace,parallelization=control$parallelization))
return(list(Minim=x@Fit@logLikel,inismoTransMat=x@Fit@smoTransMat,inismoTransMatrob=x@Fit@smoProb))
}
if(parallelization){
junk <- clusterEvalQ(cl, library(MSwM))
paralRes=parLapply(cl, c(1:maxiterOuter),paralel)
stopCluster(cl)
} else {
paralRes=lapply(c(1:maxiterOuter),paralel)
}
Minim=paralRes[[1]][["Minim"]]
inismoTransMat=paralRes[[1]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[1]][["inismoTransMatrob"]]
i=2
while(i<=maxiterOuter){
if(Minim>paralRes[[i]][["Minim"]]){
Minim=paralRes[[i]][["Minim"]]
inismoTransMat=paralRes[[i]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[i]][["inismoTransMatrob"]]
}
i=i+1
}
if (control$trace) cat("Initial Value:",Minim,"\n")
object@Fit@smoTransMat=inismoTransMat
object@Fit@smoProb=inismoTransMatrob
object=iteraEM(object,dades,control)
if (control$trace) cat("Calculating standard errors...\n")
set.seed(1)
object <- ans
k=object["k"]
swi=object["switch"]
co=object["Coef"]
constX=function(el,swit){
if(swit){ mat=diag(1,k) }else{ mat=rep(1,k)}
kronecker(el,mat)
}
Xini=model.matrix(object["model"])
X=NULL
for(i in 1:ncol(Xini)){ X=cbind(X,constX(Xini[,i,drop=F],swi[i])) }
y=kronecker(as.matrix(object["model"]$model[,1,drop=F]),rep(1,k))
dades=data.frame(y=y,X)
mprob=object@transMat[-1,,drop=F]
object@transMat=matrix(c(1-apply(mprob,2, function(x) sum(x)),mprob),nrow=object["k"],byrow=T)
object@transMat[object@transMat<0]=0
object@transMat[object@transMat>1]=1
object=msmSmooth(object)
maxiterInner=control$maxiterInner
maxiterOuter=control$maxiterOuter
parallelization=control$parallelization
if(parallelization){
mc=detectCores(logical = TRUE)
cl <- makeCluster(mc)
#clusterExport(cl,c("dades","object","control","maxiterInner"))
}
paralel=function(id){
x<-object
smoTransMat=lapply(vector("list",nrow(x@Fit@filtProb)),function(el){
ma=runif(k*k)
matrix(ma/sum(ma),ncol=k)
})
smoTransMatrob=rbind(t(sapply(smoTransMat,function(el)apply(el,1,sum))),runif(k))
x@Fit@smoTransMat<-smoTransMat
x@Fit@smoProb=smoTransMatrob
x=iteraEM(x,dades,control=list(maxiter=maxiterInner,tol=control$tol,trace=control$trace,parallelization=control$parallelization))
return(list(Minim=x@Fit@logLikel,inismoTransMat=x@Fit@smoTransMat,inismoTransMatrob=x@Fit@smoProb))
}
if(parallelization){
junk <- clusterEvalQ(cl, library(MSwM))
paralRes=parLapply(cl, c(1:maxiterOuter),paralel)
stopCluster(cl)
} else {
paralRes=lapply(c(1:maxiterOuter),paralel)
}
Minim=paralRes[[1]][["Minim"]]
inismoTransMat=paralRes[[1]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[1]][["inismoTransMatrob"]]
i=2
while(i<=maxiterOuter){
if(Minim>paralRes[[i]][["Minim"]]){
Minim=paralRes[[i]][["Minim"]]
inismoTransMat=paralRes[[i]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[i]][["inismoTransMatrob"]]
}
i=i+1
}
if (control$trace) cat("Initial Value:",Minim,"\n")
object@Fit@smoTransMat=inismoTransMat
object@Fit@smoProb=inismoTransMatrob
object=iteraEM(object,dades,control)
if (control$trace) cat("Calculating standard errors...\n")
k=object["k"]
swi=object["switch"]
co=object["Coef"]
constX=function(el,swit){
if(swit){ mat=diag(1,k) }else{ mat=rep(1,k)}
kronecker(el,mat)
}
Xini=model.matrix(object["model"])
X=NULL
for(i in 1:ncol(Xini)){ X=cbind(X,constX(Xini[,i,drop=F],swi[i])) }
y=kronecker(as.matrix(object["model"]$model[,1,drop=F]),rep(1,k))
dades=data.frame(y=y,X)
mprob=object@transMat[-1,,drop=F]
object@transMat=matrix(c(1-apply(mprob,2, function(x) sum(x)),mprob),nrow=object["k"],byrow=T)
object@transMat[object@transMat<0]=0
object@transMat[object@transMat>1]=1
object=msmSmooth(object)
maxiterInner=control$maxiterInner
maxiterOuter=control$maxiterOuter
parallelization=control$parallelization
if(parallelization){
mc=detectCores(logical = TRUE)
cl <- makeCluster(mc)
#clusterExport(cl,c("dades","object","control","maxiterInner"))
}
paralel=function(id){
x<-object
smoTransMat=lapply(vector("list",nrow(x@Fit@filtProb)),function(el){
ma=runif(k*k)
matrix(ma/sum(ma),ncol=k)
})
smoTransMatrob=rbind(t(sapply(smoTransMat,function(el)apply(el,1,sum))),runif(k))
x@Fit@smoTransMat<-smoTransMat
x@Fit@smoProb=smoTransMatrob
x=iteraEM(x,dades,control=list(maxiter=maxiterInner,tol=control$tol,trace=control$trace,parallelization=control$parallelization))
return(list(Minim=x@Fit@logLikel,inismoTransMat=x@Fit@smoTransMat,inismoTransMatrob=x@Fit@smoProb))
}
if(parallelization){
junk <- clusterEvalQ(cl, library(MSwM))
paralRes=parLapply(cl, c(1:maxiterOuter),paralel)
stopCluster(cl)
} else {
paralRes=lapply(c(1:maxiterOuter),paralel)
}
Minim=paralRes[[1]][["Minim"]]
inismoTransMat=paralRes[[1]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[1]][["inismoTransMatrob"]]
i=2
while(i<=maxiterOuter){
if(Minim>paralRes[[i]][["Minim"]]){
Minim=paralRes[[i]][["Minim"]]
inismoTransMat=paralRes[[i]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[i]][["inismoTransMatrob"]]
}
i=i+1
}
if (control$trace) cat("Initial Value:",Minim,"\n")
object@Fit@smoTransMat=inismoTransMat
object@Fit@smoProb=inismoTransMatrob
object=iteraEM(object,dades,control)
if (control$trace) cat("Calculating standard errors...\n")
set.seed(1)
if (tail(object["switch"],1)==F){
lstd=log(object["std"][1])
} else {
lstd=log(object["std"])
}
swi=object["switch"][-length(object["switch"])]
param=c(lstd,
logit(matrix(object["transMat"][1:object["k"]-1,],nrow=1,byrow=T)),
object["Coef"][1,!swi],
matrix(t(as.matrix(object["Coef"])[,swi]),nrow=1))
res=fdHess(
pars=param,
fun=fopt.lm,
object=object
)
library("nlme", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library("matlib", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
if (tail(object["switch"],1)==F){
lstd=log(object["std"][1])
} else {
lstd=log(object["std"])
}
swi=object["switch"][-length(object["switch"])]
param=c(lstd,
logit(matrix(object["transMat"][1:object["k"]-1,],nrow=1,byrow=T)),
object["Coef"][1,!swi],
matrix(t(as.matrix(object["Coef"])[,swi]),nrow=1))
res=fdHess(
pars=param,
fun=fopt.lm,
object=object
)
long=length(lstd)+(object["k"]-1)*object["k"]
mi=sum(!swi)
r <- res$Hessian
View(r)
hessian=sqrt(abs(diag(Ginv(res$Hessian))))
library(MSwM2)
library(MSwM2)
library(MSwM2)
library(MSwM2)
load("~/Thesis/Data/results_switch.RData")
newdata <- test_g2_L16A
object <- mswm_L16A_NN
p <- object@p
k <- object["k"]
model <- object["model"]
Coef <- object["Coef"]
std <- object["std"]
P <- object["transMat"]
fProb <- object["Fit"]["filtProb"]
margLik <- object["Fit"]["margLik"]
nr <- length(model$model[,1])
var_name <- colnames(model$model) # all variables name
var_name <- var_name[1:(length(var_name)-p)] # discard AR term (if any)
test <- subset(newdata, select=var_name) # subset (dependent and independent variables)
if(p > 0){
ar <- t(model$model[nr:(nr-p+1),1,drop=F]) # lag p from training data
var <- test[,1]
if(length(var) > 1){
ar <- apply(as.matrix(1:p),1,function(el){
length(var)=length(var)-el
var=c(rep(ar[el:1]),var)
return(var)
})}
colnames(ar) <- paste(names(model$model)[1],"_",1:p,sep="") # insert name
}
test <- cbind(test, ar) # include back AR term
# relevel the reference of the factor level to be the same as in the training model
for(i in names(model$xlevels)){
ref_level <- model$xlevels[[i]][1]
test[,i] <- relevel(test[,i], ref_level)
}
terms <- model.matrix(as.formula(paste(colnames(test)[1], " ~ ", paste(colnames(test)[-1], collapse= "+"))), data=test)
CondMean <- as.matrix(terms) %*% t(as.matrix(Coef))
error <- as.matrix(test[,1,drop=F]) %*% matrix(rep(1,k),nrow=1) - CondMean
Likel <- t(dnorm(t(error),0,std))
st <- c()
for(i in 1:nrow(test)){
fProb_new <- t(P %*% t(fProb[nr-1+i,,drop=F])) * (Likel[i,,drop=F])
margLik_new <- sum(fProb_new)
fProb_new <- (fProb_new / margLik_new)
fProb <- rbind(fProb, fProb_new) # filtered prob of t+1 conditional on the info in t+1
margLik <- rbind(margLik, margLik_new)
st <- c(st, which.max(fProb_new))
}
# names(s
st
fProb
n <- nrow(test)
(nr-n)
nr
nrow(fProb)
(nr+n)
fProb_new
which.max(fProb_new)
?NaN
0/0
error
Likel
a <- c(1,2)
c(a, Na)
c(a, NA)
i=7
t(fProb[nr-1+i,,drop=F])
tail(fProb)
library(MSwM2)
library(MSwM2)
library(MSwM2)
load("~/Dropbox/Thesis/Data/results_switch.RData")
library(MSwM2)
library(ecp)
library(ggplot2)
library(reshape2)
pred_L16A <- MSwM2::statePredict(mswm_L16A_NN, test_g2_L16A) ##FIX
state_L16A_3 <- gen(mswm_L16A_NN, train_g2_L16A)
state <- factor(pred_L16A)
state <- c(state, NA)
index=seq(1,nrow(test_g2_L16A))
xmin=index-0.5
xmax=index+0.5
y=test_g2_L16A$TotCpu
ymin=ifelse(unique(state_L16A_3$ymin) > min(y), min(y), unique(state_L16A_3$ymin))
ymax=ifelse(unique(state_L16A_3$ymax) > max(y), unique(state_L16A_3$ymax), max(y))
n=nrow(test_g2_L16A)
ans <- data.frame(index,xmin,xmax,state=factor(state),y=y,ymin=rep(ymin,n),ymax=rep(ymax,n))
ggplot(data=ans, aes(x=index, y=y)) + geom_line() +
geom_rect(data=ans, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=state), alpha=0.2, inherit.aes=FALSE) +
scale_fill_manual(values=c("red","green","blue")) +
ylab("TotCpu") + ggtitle("L16A") + theme_bw()
state_L16B_3 <- gen(mswm_L16B_NYY, train_g2_L16B)
ggplot(data=state_L16B_3, aes(x=index, y=y)) + geom_line() +
geom_rect(data=state_L16B_3, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=state), alpha=0.2, inherit.aes=FALSE) +
scale_fill_manual(values=c("red","green","blue")) +
ylab("TotCpu") + ggtitle("L16B_NYY") + theme_bw()
state_L16A_3 <- gen(mswm_L16A_NN, train_g2_L16A)
ggplot(data=state_L16A_3, aes(x=index, y=y)) + geom_line() +
geom_rect(data=state_L16A_3, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=state), alpha=0.2, inherit.aes=FALSE) +
scale_fill_manual(values=c("red","green","blue")) +
ylab("TotCpu") + ggtitle("L16A_NN") + theme_bw()
state_L17A_3 <- gen(mswm_L17A_NNN, train_g2_L17A)
ggplot(data=state_L17A_3, aes(x=index, y=y)) + geom_line() +
geom_rect(data=state_L17A_3, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=state), alpha=0.2, inherit.aes=FALSE) +
scale_fill_manual(values=c("red","green","blue")) +
ylab("TotCpu") + ggtitle("L17A_NNN") + theme_bw()
L16B_3 <- as.data.frame(mswm_L16B_3@Fit@smoProb)
L16B_3 <- cbind(index=seq(1,nrow(L16B_3)),L16B_3)
colnames(L16B_3) <- c("index","State 1","State 2","State 3")
L16B_3 <- melt(L16B_3, id="index")
ggplot(data=L16B_3, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L16B") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
L16B_2 <- as.data.frame(mswm_L16B_2@Fit@smoProb)
L16B_2 <- cbind(index=seq(1,nrow(L16B_2)),L16B_2)
colnames(L16B_2) <- c("index","State 1","State 2")
L16B_2 <- melt(L16B_2, id="index")
ggplot(data=L16B_2, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L16B") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
L16A_3 <- as.data.frame(mswm_L16A_3@Fit@smoProb)
L16A_3 <- cbind(index=seq(1,nrow(L16A_3)),L16A_3)
colnames(L16A_3) <- c("index","State 1","State 2","State 3")
L16A_3 <- melt(L16A_3, id="index")
ggplot(data=L16A_3, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L16A") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
#--------------------------------#
# smoothed prob plot
L16A_2 <- as.data.frame(mswm_L16A_2@Fit@smoProb)
L16A_2 <- cbind(index=seq(1,nrow(L16A_2)),L16A_2)
colnames(L16A_2) <- c("index","State 1","State 2")
L16A_2 <- melt(L16A_2, id="index")
ggplot(data=L16A_2, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L16A") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
L17A_3 <- as.data.frame(mswm_L17A_3@Fit@smoProb)
L17A_3 <- cbind(index=seq(1,nrow(L17A_3)),L17A_3)
colnames(L17A_3) <- c("index","State 1","State 2","State 3")
L17A_3 <- melt(L17A_3, id="index")
ggplot(data=L17A_3, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L17A") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
L17A_2 <- as.data.frame(mswm_L17A_2@Fit@smoProb)
L17A_2 <- cbind(index=seq(1,nrow(L17A_2)),L17A_2)
colnames(L17A_2) <- c("index","State 1","State 2")
L17A_2 <- melt(L17A_2, id="index")
ggplot(data=L17A_2, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L17A") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
load("~/Dropbox/Thesis/Data/results.RData")
L16B_3 <- as.data.frame(mswm_L16B_3@Fit@smoProb)
L16B_3 <- cbind(index=seq(1,nrow(L16B_3)),L16B_3)
colnames(L16B_3) <- c("index","State 1","State 2","State 3")
L16B_3 <- melt(L16B_3, id="index")
ggplot(data=L16B_3, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L16B") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
L16B_2 <- as.data.frame(mswm_L16B_2@Fit@smoProb)
L16B_2 <- cbind(index=seq(1,nrow(L16B_2)),L16B_2)
colnames(L16B_2) <- c("index","State 1","State 2")
L16B_2 <- melt(L16B_2, id="index")
ggplot(data=L16B_2, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L16B") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
# smoothed prob plot
L16A_3 <- as.data.frame(mswm_L16A_3@Fit@smoProb)
L16A_3 <- cbind(index=seq(1,nrow(L16A_3)),L16A_3)
colnames(L16A_3) <- c("index","State 1","State 2","State 3")
L16A_3 <- melt(L16A_3, id="index")
ggplot(data=L16A_3, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L16A") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
# smoothed prob plot
L16A_2 <- as.data.frame(mswm_L16A_2@Fit@smoProb)
L16A_2 <- cbind(index=seq(1,nrow(L16A_2)),L16A_2)
colnames(L16A_2) <- c("index","State 1","State 2")
L16A_2 <- melt(L16A_2, id="index")
ggplot(data=L16A_2, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L16A") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
L17A_3 <- as.data.frame(mswm_L17A_3@Fit@smoProb)
L17A_3 <- cbind(index=seq(1,nrow(L17A_3)),L17A_3)
colnames(L17A_3) <- c("index","State 1","State 2","State 3")
L17A_3 <- melt(L17A_3, id="index")
ggplot(data=L17A_3, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L17A") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
L17A_2 <- as.data.frame(mswm_L17A_2@Fit@smoProb)
L17A_2 <- cbind(index=seq(1,nrow(L17A_2)),L17A_2)
colnames(L17A_2) <- c("index","State 1","State 2")
L17A_2 <- melt(L17A_2, id="index")
ggplot(data=L17A_2, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L17A") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
library(ecp)
set.seed(1)
Ediv_L16B <- e.divisive(matrix(train_g2_L16B$TotCpu), R=499, min.size=5)
Ediv_L16B$k.hat
Ediv_L16B$estimates
out <- Ediv_L16B$estimates[c(-1,-length(Ediv_L16B$estimates))]
dat <- data.frame(index=seq(1,nrow(train_g2_L16B)), TotCpu=train_g2_L16B$TotCpu)
ggplot(data=dat, aes(x=index, y=TotCpu)) + geom_line() + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
geom_vline(xintercept=out, colour="red", linetype="longdash") +
ggtitle("E-divisive L16B") + theme_bw()
Ediv_L16A <- e.divisive(matrix(train_g2_L16A$TotCpu), R=499, min.size=5)
Ediv_L16A$k.hat
Ediv_L16A$estimates
out <- Ediv_L16A$estimates[c(-1,-length(Ediv_L16A$estimates))]
dat <- data.frame(index=seq(1,nrow(train_g2_L16A)), TotCpu=train_g2_L16A$TotCpu)
ggplot(data=dat, aes(x=index, y=TotCpu)) + geom_line() +
geom_vline(xintercept=out, colour="red", linetype="dashed") +
ggtitle("E-divisive L16A") + theme_bw()
###############
set.seed(1)
Ediv_L17A <- e.divisive(matrix(train_g2_L17A$TotCpu), R=499, min.size=5)
Ediv_L17A$k.hat
Ediv_L17A$estimates
out <- Ediv_L17A$estimates[c(-1,-length(Ediv_L17A$estimates))]
dat <- data.frame(index=seq(1,nrow(train_g2_L17A)), TotCpu=train_g2_L17A$TotCpu)
ggplot(data=dat, aes(x=index, y=TotCpu)) + geom_line() +
geom_vline(xintercept=out, colour="red", linetype="dashed") +
ggtitle("E-divisive L17A") + theme_bw()
ecp_L16B <- c(130,135,153,170)
L16B_3 <- as.data.frame(mswm_L16B_NYY@Fit@smoProb)
L16B_3 <- cbind(index=seq(1,nrow(L16B_3)),L16B_3)
colnames(L16B_3) <- c("index","State 1","State 2","State 3")
L16B_3 <- melt(L16B_3, id="index")
g <- ggplot(data=L16B_3, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L16B_NYY") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
g + geom_vline(xintercept=ecp_L16B, color="black", size=0.6, linetype="longdash")
load("~/Dropbox/Thesis/Data/results_switch.RData")
ecp_L16B <- c(130,135,153,170)
L16B_3 <- as.data.frame(mswm_L16B_NYY@Fit@smoProb)
L16B_3 <- cbind(index=seq(1,nrow(L16B_3)),L16B_3)
colnames(L16B_3) <- c("index","State 1","State 2","State 3")
L16B_3 <- melt(L16B_3, id="index")
g <- ggplot(data=L16B_3, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L16B_NYY") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
g + geom_vline(xintercept=ecp_L16B, color="black", size=0.6, linetype="longdash")
ecp_L17A <- c(9,77,82,105)
L17A_3 <- as.data.frame(mswm_L17A_NNN@Fit@smoProb)
L17A_3 <- cbind(index=seq(1,nrow(L17A_3)),L17A_3)
colnames(L17A_3) <- c("index","State 1","State 2","State 3")
L17A_3 <- melt(L17A_3, id="index")
g <- ggplot(data=L17A_3, aes(x=index, y=value, colour=variable)) + geom_line() +
ylab("Smoothed Probabilities") + ggtitle("L17A_NNN") + scale_color_manual(values=c("#F8766D","#00BA38","#619CFF")) +
theme_bw() + theme(legend.title = element_blank())
g + geom_vline(xintercept=ecp_L17A, color="black", size=0.6, linetype="longdash")
pred_L16A <- MSwM2::statePredict(mswm_L16A_NN, test_g2_L16A) ##FIX
state_L16A_3 <- gen(mswm_L16A_NN, train_g2_L16A)
state <- factor(pred_L16A)
state <- c(state, NA)
index=seq(1,nrow(test_g2_L16A))
xmin=index-0.5
xmax=index+0.5
y=test_g2_L16A$TotCpu
ymin=ifelse(unique(state_L16A_3$ymin) > min(y), min(y), unique(state_L16A_3$ymin))
ymax=ifelse(unique(state_L16A_3$ymax) > max(y), unique(state_L16A_3$ymax), max(y))
n=nrow(test_g2_L16A)
ans <- data.frame(index,xmin,xmax,state=factor(state),y=y,ymin=rep(ymin,n),ymax=rep(ymax,n))
ggplot(data=ans, aes(x=index, y=y)) + geom_line() +
geom_rect(data=ans, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=state), alpha=0.2, inherit.aes=FALSE) +
scale_fill_manual(values=c("red","green","blue")) +
ylab("TotCpu") + ggtitle("L16A") + theme_bw()
pred_L16B <- MSwM2::statePredict(mswm_L16B_NYY, test_g2_L16B)
# 1  1  1  1  1  3  1  3  3  3  1  3  3  3  2  3  3  3  3  3  3  3  1  3  1
# plot with state area
gen <- function(object,data){
state <- sapply(1:nrow(data), function(x) which.max(object@Fit@smoProb[x,]))
state <- factor(state)
index=seq(1,nrow(data))
xmin=index-0.5
xmax=index+0.5
y=data$TotCpu
ans <- data.frame(index,xmin,xmax,state,y=y,ymin=min(y),ymax=max(y))
return(ans)
}
gen2 <- function(x,dat,data){
state <- factor(x)
index=seq(1,nrow(data))
xmin=index-0.5
xmax=index+0.5
y=data$TotCpu
ymin=ifelse(unique(dat$ymin) > min(y), min(y), unique(dat$ymin))
ymax=ifelse(unique(dat$ymax) > max(y), unique(dat$ymax), max(y))
n=nrow(data)
ans <- data.frame(index,xmin,xmax,state,y=y,ymin=rep(ymin,n),ymax=rep(ymax,n))
return(ans)
}
state_L16B_3 <- gen(mswm_L16B_NYY, train_g2_L16B)
state_test_L16B <- gen2(pred_L16B, state_L16B_3, test_g2_L16B)
ggplot(data=state_test_L16B, aes(x=index, y=y)) + geom_line() +
geom_rect(data=state_test_L16B, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=state), alpha=0.2, inherit.aes=FALSE) +
scale_fill_manual(values=c("red","green","blue")) +
ylab("TotCpu") + ggtitle("L16B") + theme_bw()
pred_L17A <- MSwM2::statePredict(mswm_L17A_NNN, test_g2_L17A)
# 1  1  1  2  1  3  2  3  3  2  2  2  2  2  2
state_L17A_3 <- gen(mswm_L17A_NNN, train_g2_L17A)
state_test_L17A <- gen2(pred_L17A, state_L17A_3, test_g2_L17A)
ggplot(data=state_test_L17A, aes(x=index, y=y)) + geom_line() +
geom_rect(data=state_test_L17A, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=state), alpha=0.2, inherit.aes=FALSE) +
scale_fill_manual(values=c("red","green","blue")) +
ylab("TotCpu") + ggtitle("L17A") + theme_bw()
set.seed(1)
mswm_L17A_4 <- MSwM2::msmFit(mod_L17A, k=4, p=1, sw=rep(TRUE,length(mod_L17A$coefficients)+1+1), control=list(trace=TRUE, maxiter=500, parallel=FALSE))
mswm_L17A_4
set.seed(1)
mswm_L16A_4 <- MSwM2::msmFit(mod_L16A, k=4, p=1, sw=rep(TRUE,length(mod_L16A$coefficients)+1+1), control=list(trace=TRUE, maxiter=500, parallel=FALSE))
set.seed(1)
mswm_L16B_4 <- MSwM2::msmFit(mod_L16B, k=4, p=1, sw=rep(TRUE,length(mod_L16B$coefficients)+1+1), control=list(trace=TRUE, maxiter=500, parallel=FALSE))
mswm_L16B_4
