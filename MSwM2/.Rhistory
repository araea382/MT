plot(ts(z),col=1,ylim=c(min(z),max(z)),main="",xlab="",ylab="")
plot(0,type="l",xlim=c(1,length(t(v))),ylim=c(min(v),max(v)),main="",xlab=paste(names(v),"with Smooth Probabilities"),ylab="")
apply(val,1,function(el) rect(el[1],min(v),el[2],max(v),col="light grey",border=NA))
par(new=T,las=1,bty="o")
plot(ts(v),col=1,ylim=c(min(v),max(v)),main="",xlab="",ylab="")
}
)
}
)
par(mfrow=c(1,1))
return(invisible())
}
setMethod(f="plotReg",signature=c("MSM.linear","missing","ANY"),definition=.MSM.larg.plotReg)
.MSM.sma.plotReg=function(x,expl,regime){
apply(as.matrix(expl),1,function(var) if(!any(apply(as.matrix(names(x["model"]$model[-1])),1,function(el) ifelse(var==el,T,F)))) stop("The name of the variable is not correct.\n"))
if(missing(regime)){
regime=1
}else{
if(is.numeric(regime)){
if(any(regime > x["k"])|any(regime < 1)) stop("You must to write a correct regime.")
}else{
stop("regime must to be numeric.")
}
}
z=x["model"]$model[1]
apply(as.matrix(1:length(regime)),1,function(j){
apply(as.matrix(1:length(expl)),1,function(i){
a=layout(matrix(c(1,2,1,2),ncol=1,nrow=2),TRUE)
y=x["Fit"]["smoProb"][-1,regime[j]]
v=x["model"]$model[expl[i]]
par(omi=c(0.1,0.1,0.1,0.1))
par(las=1,yaxt="n")
plot(0,type="l",xlim=c(1,length(t(z))),ylim=c(min(z),max(z)),main=paste("Regime",regime[j],sep=""),xlab=paste(names(z),"with Smooth Probabilities"),ylab="")
val=cbind(which(diff(c(0,findInterval(y,0.5)))==1),which(diff(c(findInterval(y,0.5),0))==-1))
apply(val,1,function(el) rect(el[1],min(z),el[2],max(z),col="light grey",border=NA))
par(new=T,las=1,bty="o",yaxt="n")
plot(ts(z),col=1,ylim=c(min(z),max(z)),main="",xlab="",ylab="")
plot(0,type="l",xlim=c(1,length(t(v))),ylim=c(min(v),max(v)),main="",xlab=paste(names(v),"with Smooth Probabilities"),ylab="")
apply(val,1,function(el) rect(el[1],min(v),el[2],max(v),col="light grey",border=NA))
par(new=T,las=1,bty="o",yaxt="n")
plot(ts(v),col=1,ylim=c(min(v),max(v)),main="",xlab="",ylab="")
}
)
}
)
par(mfrow=c(1,1))
return(invisible())
}
setMethod(f="plotReg",signature=c("MSM.linear","character","ANY"),definition=.MSM.sma.plotReg)
##########
##### plotDiag
.MSM.larg.plotDiag=function(x,regime,which){
if(missing(which)){
which=1:3
}else{
if(is.numeric(which)){
if(any(which > 3)|any(which < 1)) stop("You must to write numbers between 1 and 3.")
}else{
stop("You must write numbers.")
}
}
residPooled=apply(x["Fit"]["error"]*x["Fit"]["smoProb"][-1,],1,sum)
if(any(which==1)){
ts.plot(residPooled,main="Pooled residuals")
abline(h=0)
abline(h=c(-3*sd(residPooled),3*sd(residPooled)),lty=3,col=4)
}
if(any(which==2)){
qqnorm(residPooled,main="Normal Q-Q Plot Pooled Residuals")
qqline(residPooled,col=2,lwd=2)
}
if(any(which==3)){
par(mfrow=c(2,2))
acf(residPooled,ylim=c(-1,1),main="ACF of Residuals")
pacf(residPooled,ylim=c(-1,1),main="PACF of Residuals")
acf(residPooled^2,ylim=c(-1,1),main="ACF of Square Residuals")
pacf(residPooled^2,ylim=c(-1,1),main="PACF of Square Residuals")
par(mfrow=c(1,1))
}
return(invisible())
}
setMethod(f="plotDiag",signature=c("MSM.linear","missing","ANY"),definition=.MSM.larg.plotDiag)
.MSM.larg.plotDiag=function(x,regime,which){
if(regime[length(regime)]=="all"){
aux=c(1:x["k"])
}else{
if(any(regime > x["k"])|any(regime < 1)) stop("You must to write a correct regime.")
aux=regime
}
if(missing(which)){
which=1:3
}else{
if(is.numeric(which)){
if(any(which > 3)|any(which < 1)) stop("You must to write numbers between 1 and 3.")
}else{
stop("You must write numbers.")
}
}
apply(as.matrix(aux),1,function(i){
if(any(which==1)){
ts.plot(x["Fit"]["error"][,i],main=paste("Regime ",i,sep=""),ylab="Residuals")
abline(h=0)
abline(h=c(-3*sd(x["Fit"]["error"][,i]),3*sd(x["Fit"]["error"][,i])),lty=3,col=4)
}
if(any(which==2)){
qqnorm(x["Fit"]["error"][,i],main=paste("Normal Q-Q Plot Regime ",i,sep=""))
qqline(x["Fit"]["error"][,i],col=2,lwd=2)
}
if(any(which==3)){
par(mfrow=c(2,2))
acf(x["Fit"]["error"][,i],ylim=c(-1,1),main=paste("ACF of Residuals. Reg: ",i,sep=""))
pacf(x["Fit"]["error"][,i],ylim=c(-1,1),main=paste("PACF of Residuals. Reg: ",i,sep=""))
acf(x["Fit"]["error"][,i]^2,ylim=c(-1,1),main=paste("ACF of Square Resid. Reg: ",i,sep=""))
pacf(x["Fit"]["error"][,i]^2,ylim=c(-1,1),main=paste("PACF of Square Resid. Reg: ",i,sep=""))
par(mfrow=c(1,1))
}
}
)
return(invisible())
}
setMethod(f="plotDiag",signature=c("MSM.linear","ANY","ANY"),definition=.MSM.larg.plotDiag)
##########
##### resid
.MSM.lm.sma.msmResid=function(object,regime){
return(apply(object["Fit"]["error"]*object["Fit"]["smoProb"][-1,],1,sum))
}
setMethod(f="msmResid",signature=c("MSM.lm","missing"),definition=.MSM.lm.sma.msmResid)
.MSM.lm.larg.msmResid=function(object,regime){
if(regime[length(regime)]=="all"){
aux=c(1:object["k"])
res=apply(as.matrix(aux),1,function(i) object["Fit"]["error"][,i])
dimnames(res)[[2]]=paste("Regime ",1:object["k"],sep="")
return(res)
}else{
if(any(regime > object["k"])|any(regime < 1)) stop("You must to write a correct regime.")
aux=regime
return(object["Fit"]["error"][,regime])
}
}
setMethod(f="msmResid",signature=c("MSM.lm","ANY"),definition=.MSM.lm.larg.msmResid)
# .MSM.glm.sma.msmResid=function(object,regime){
# 	res=object["Fit"]["error"]/sqrt(object@family$variance(object["Fit"]@CondMean))
# 	return(apply(res*object["Fit"]["smoProb"][-1,],1,sum))
# }
# setMethod(f="msmResid",signature=c("MSM.glm","missing"),definition=.MSM.glm.sma.msmResid)
#
# .MSM.glm.larg.msmResid=function(object,regime){
# 	if(regime[length(regime)]=="all"){
# 		aux=c(1:object["k"])
# 		res=apply(as.matrix(aux),1,function(i) object["Fit"]["error"][,i]/sqrt(object@family$variance(object["Fit"]@CondMean[,i])))
# 		dimnames(res)[[2]]=paste("Regime ",1:object["k"],sep="")
# 		return(res)
# 	}else{
# 		if(any(regime > object["k"])|any(regime < 1)) stop("You must to write a correct regime.")
# 		aux=regime
# 		return(object["Fit"]["error"][,regime]/sqrt(object@family$variance(object["Fit"]@CondMean[,regime])))
# 		}
# }
# setMethod(f="msmResid",signature=c("MSM.glm","ANY"),definition=.MSM.glm.larg.msmResid)
AIC.MSM.lm <-
function(object, ..., k=2)
{
swi=object@switch
np=object["k"]*sum(swi)+sum(!swi)
return(2*object["Fit"]["logLikel"]+k*np)
}
AIC.MSM.glm <-
function(object, ..., k=2)
{
swi=object@switch
np=object["k"]*sum(swi)+sum(!swi)
return(2*object["Fit"]["logLikel"]+k*np)
}
AIC <-
## Return the object's value of the Bayesian Information Criterion
function(object, ...,k=2) UseMethod("AIC")
intervals.MSM.lm=function(object,level=0.95,...){
cat("\nAproximate intervals for the coefficients. Level=",level,"\n")
aux=names(object["Coef"])
lower=object["Coef"]-qnorm(1-(1-level)/2)*object["seCoef"]
upper=object["Coef"]+qnorm(1-(1-level)/2)*object["seCoef"]
a=apply(as.matrix(1:length(aux)),1,function(i){
cat(paste("\n",aux[i],": \n",sep=""))
#cat("---------\n")
intmat=cbind(lower[aux[i]],object["Coef"][aux[i]],upper[aux[i]])
dimnames(intmat)=list(c(paste("Regime ",1:object["k"],sep="")),c("Lower","Estimation","Upper"))
print(intmat)
#cat("---------\n")
cat("\n")
}
)
}
intervals.MSM.glm=function(object,level=0.95,...){
cat("\nAproximate intervals for the coefficients. Level=",level,"\n")
aux=names(object["Coef"])
lower=object["Coef"]-qnorm(1-(1-level)/2)*object["seCoef"]
upper=object["Coef"]+qnorm(1-(1-level)/2)*object["seCoef"]
a=apply(as.matrix(1:length(aux)),1,function(i){
cat(paste("\n",aux[i],": \n",sep=""))
#cat("---------\n")
intmat=cbind(lower[aux[i]],object["Coef"][aux[i]],upper[aux[i]])
dimnames(intmat)=list(c(paste("Regime ",1:object["k"],sep="")),c("Lower","Estimation","Upper"))
print(intmat)
#cat("---------\n")
cat("\n")
}
)
}
intervals <-
## Return the object's value of the Bayesian Information Criterion
function(object,level=0.95,...) UseMethod("intervals")
#########
#### msmfilter
.MSM.lm.msmFilter= function(object){
model=object["model"]
k=object["k"]
Coef=object["Coef"]
std=object["std"]
P=object["transMat"]
# Calculation of some preliminar variables
nr=length(model$model[,1])
terms=model.matrix(model)
CondMean=as.matrix(terms)%*%t(as.matrix(Coef))
error= as.matrix(model$model[,1,drop=F])%*%matrix(rep(1,k),nrow=1)-CondMean
Likel=t(dnorm(t(error),0,std))
###Filtered Probabilities ####
fProb=matrix(data=0,nrow=nr,ncol=k)
margLik=matrix(data=0,nrow=nr,ncol=1)
fProb[1,]= (P%*%matrix(object["iniProb"],ncol=1))*t(Likel[1,,drop=F])
margLik[1,1] = sum(fProb[1,])
fProb[1,] = fProb[1,] / margLik[1,1]
for (i in 2:nr){
# Mixtura de funcions
# MS filter equation
# MS filter Filter margLikuation for probabilities
fProb[i,] = (P%*%t(fProb[i-1,,drop=F]))*t(Likel[i,,drop=F])
margLik[i,1] = sum(fProb[i,])
fProb[i,] = fProb[i,]/margLik[i,1]
}
# Negative sum of log Likelihood
loglik=-sum(log(margLik[1:nr]))
# Passing up to output structure
ans=new(Class="MSM.fitted",CondMean=CondMean,error=error, Likel=Likel,margLik=margLik, filtProb=fProb, logLikel=loglik )
return(ans)
}
setMethod(f="msmFilter",signature=c("MSM.lm"),definition=.MSM.lm.msmFilter)
.MSM.glm.msmFilter=function(object){
model=object["model"]
k=object["k"]
family=model$family
Coef=object["Coef"]
P=object["transMat"]
# Calculation of some preliminar variables
nr=length(model$model[,1])
terms=model.matrix(model)
CondMean=family$linkinv(as.matrix(terms)%*%t(as.matrix(Coef)))
error= as.matrix(model$model[,1,drop=F])%*%matrix(rep(1,k),nrow=1)-CondMean
Likel=object@Likelihood(as.matrix(model$model[,1,drop=F])%*%matrix(rep(1,k),nrow=1),mu=CondMean)
###Filtered Probabilities ####
fProb=matrix(data=0,nrow=nr,ncol=k)
margLik=matrix(data=0,nrow=nr,ncol=1)
margLik[1,1]=sum ((P%*%matrix(object["iniProb"],ncol=1)) * t(Likel[1,,drop=F]))
fProb[1,]= ((P%*%matrix(object["iniProb"],ncol=1))*t(Likel[1,,drop=F]))/margLik[1,1]
for (i in 2:nr){
# Mixtura de funcions
# MS filter margLikuation
margLik[i,1]=sum ((P%*%t(fProb[i-1,,drop=F])) * t(Likel[i,,drop=F]))
# MS filter Filter margLikuation for probabilities
fProb[i,]= ((P%*%t(fProb[i-1,,drop=F])*t(Likel[i,,drop=F]))/margLik[i,1])
}
# Negative sum of log Likelihood for fmincon (fmincon minimzes the function)
loglik=-sum(log(margLik[1:nr]))
# Passing up to output structure
ans=new(Class="MSM.fitted",CondMean=CondMean,error=error, Likel=Likel,margLik=margLik, filtProb=fProb, logLikel=loglik )
return(ans)
}
setMethod(f="msmFilter",signature=c("MSM.glm"),definition=.MSM.glm.msmFilter)
#########
#### msmsmooth
.MSM.msmSmooth=function(object){
object@Fit=msmFilter(object)
nr=length(object["model"]$model[,1])
fProb=object["Fit"]["filtProb"]
k=object["k"]
P=object["transMat"]
smoTransMatrob=matrix(0,ncol=k,nrow=nr+1)
smoTransMatrob[nr+1,]=fProb[nr,]
#smoTransMatrob[nr+1,]=fProb[nr,]%*%t(P)
proba=rbind(object@iniProb,fProb)
pro=proba%*%t(P)
smoTransMat=list(NULL)
for (i in (nr-1):0){
smoTransMat[[i+1]]=matrix(0,ncol=k,nrow=k)
for (ini in 1:k){
smoTransMatrob[i+1,ini]=0
for (fi in 1:k){
smoTransMat[[i+1]][ini,fi]=smoTransMatrob[i+2,fi]*proba[i+1,ini]*P[fi,ini]/pro[i+1,fi]
smoTransMatrob[i+1,ini]=smoTransMatrob[i+1,ini] + smoTransMat[[i+1]][ini,fi]
}
}
}
object@Fit@smoProb=smoTransMatrob
object@Fit@smoTransMat=smoTransMat
return(object)
}
setMethod(f="msmSmooth",signature=c("MSM.linear"),definition=.MSM.msmSmooth)
#########
####optimizer
fopt.lm=function(param, object=object){
if (tail(object["switch"],1)==F){
object@std<-exp(param[1])
ini=1
} else {
object@std<-exp(param[1:object["k"]])
ini=object["k"]
}
long=ini+(object["k"]-1)*object["k"]
mprob=matrix(logitinv(c(param[(ini+1):long])),nrow=object["k"],byrow=T)
object@transMat<-matrix(c(mprob,1-apply(mprob,1, function(x) sum(x))),nrow=object["k"],byrow=T)
swi=object["switch"][-length(object["switch"])]
mi=sum(!swi)
aux=object["Coef"]
aux[,which(swi)]=as.data.frame(matrix(param[-c(1:(long+mi))],nrow=object["k"],byrow=T))
aux[,which(!swi)]=as.data.frame(matrix(rep(param[long+(1:mi)],object["k"]),nrow=object["k"],byrow=T))
object@Coef=aux
return(msmFilter(object)@logLikel)
}
# fopt.glm=function(param, object=object){
# 	long=(object["k"]-1)*object["k"]
# 	mprob=matrix(logitinv(c(param[1:long])),ncol=object["k"],byrow=T)
# 	object@transMat<-matrix(c(mprob,1-apply(mprob,2, function(x) sum(x))),nrow=object["k"],byrow=T)
# 	swi=object["switch"]
# 	mi=sum(!swi)
# 	aux=object["Coef"]
# 	aux[,which(swi)]=as.data.frame(matrix(param[-c(1:(long+mi))],nrow=object["k"],byrow=T))
# 	aux[,which(!swi)]=as.data.frame(matrix(rep(param[long+(1:mi)],object["k"]),nrow=object["k"],byrow=T))
# 	object@Coef=aux
# 	return(msmFilter(object)@logLikel)
# }
.MSM.lm.hessian=function(object){
if (tail(object["switch"],1)==F){
lstd=log(object["std"][1])
} else {
lstd=log(object["std"])
}
swi=object["switch"][-length(object["switch"])]
param=c(lstd,
logit(matrix(object["transMat"][1:object["k"]-1,],nrow=1,byrow=T)),
object["Coef"][1,!swi],
matrix(t(as.matrix(object["Coef"])[,swi]),nrow=1))
res=fdHess(
pars=param,
fun=fopt.lm,
object=object
)
# non-switching variance will have only one value
# long=object["k"]+(object["k"]-1)*object["k"]
long=length(lstd)+(object["k"]-1)*object["k"]
mi=sum(!swi)
# use Ginv(), the generalized inversed for singular matrix
# hessian=sqrt(abs(diag(solve(res$Hessian))))
# if(class(try(solve(res$Hessian), silent=TRUE))=="try-error"){
#   hessian=sqrt(abs(diag(Ginv(res$Hessian))))
# }else{
#   hessian=sqrt(abs(diag(solve(res$Hessian))))
# }
hessian=sqrt(abs(diag(Ginv(res$Hessian))))
stdaux=object["Coef"]
stdaux[,which(swi)]=as.data.frame(matrix(hessian[-c(1:(long+mi))],nrow=object["k"],byrow=T))
stdaux[,which(!swi)]=as.data.frame(matrix(rep(hessian[long+(1:mi)],object["k"]),nrow=object["k"],byrow=T))
object@seCoef=stdaux
return(object)
}
setMethod(f="hessian",signature=c("MSM.lm"),definition=.MSM.lm.hessian)
.MSM.glm.hessian=function(object){
param=c(
logit(matrix(object["transMat"][1:object["k"]-1,],nrow=1,byrow=T)),
as.matrix(object["Coef"])[1,!object["switch"]],
matrix(t(as.matrix(object["Coef"])[,object["switch"]]),nrow=1))
res=fdHess(
pars=param,
fun=fopt.glm,
object=object
)
long=(object["k"]-1)*object["k"]
mi=sum(!object["switch"])
hessian=sqrt(abs(diag(solve(res$Hessian))))
stdaux=object["Coef"]
stdaux[,which(object["switch"])]=as.data.frame(matrix(hessian[-c(1:(long+mi))],nrow=object["k"],byrow=T))
stdaux[,which(!object["switch"])]=as.data.frame(matrix(rep(hessian[long+(1:mi)],object["k"]),nrow=object["k"],byrow=T))
object@seCoef=stdaux
return(object)
}
setMethod(f="hessian",signature=c("MSM.glm"),definition=.MSM.glm.hessian)
.MSM.lm.maximEM=function(object,dades){
k=object["k"]
swi=object["switch"][-length(object["switch"])]
co=object["Coef"]
w=object["Fit"]["smoProb"][-1,]
modaux=lm(y~.-1,dades,weights=c(t(w)))
object@Coef=as.data.frame(matrix(rep(coef(modaux),rep(ifelse(swi,1,k),ifelse(swi,k,1))),nrow=k))
if (tail(object["switch"],1)==T){
object@std=sqrt(apply(w*matrix(resid(modaux),ncol=k,byrow=T)^2,2,sum)/apply(w,2,sum))
} else {
std=sum(weighted.residuals(modaux)^2)/nrow(w)
object@std=rep(sqrt(std),k)
}
names(object@Coef)=names(co)
return(object)
}
setMethod(f="maximEM",signature=c("MSM.lm","data.frame"),definition=.MSM.lm.maximEM)
.MSM.glm.maximEM=function(object,dades){
k=object["k"]
sw=object["switch"]
co=object["Coef"]
w=object["Fit"]["smoProb"][-1,]
modaux=glm(y~.-1,dades,weights=c(t(w)),family=object["model"]$family)
object@Coef=as.data.frame(matrix(rep(coef(modaux),rep(ifelse(sw,1,k),ifelse(sw,k,1))),nrow=k))
names(object@Coef)=names(co)
return(object)
}
setMethod(f="maximEM",signature=c("MSM.glm","data.frame"),definition=.MSM.glm.maximEM)
.MSM.linear.iteraEM=function(object,dades,control){
k=object["k"]
for (it in 1:control$maxiter){
oldcoef=object["Coef"]
oldll=object["Fit"]["logLikel"]
##M-step
object=maximEM(object,dades)
smoTransMatrob=object["Fit"]["smoProb"]
smoTransMat=object["Fit"]["smoTransMat"]
object@transMat=matrix(apply(matrix(unlist(smoTransMat),nrow=k*k),1,sum)/rep(apply(smoTransMatrob[-1,],2,sum),rep(k,k)),ncol=k)
object@iniProb=object["Fit"]["smoProb"][1,]
##E-step
object=msmSmooth(object)
if (control$trace) cat(" Inner Iter.",it," logLikel=",object["Fit"]["logLikel"],"\n")
if ((max(abs(object["Fit"]["logLikel"] - oldll))/(0.1 + max(abs(object["Fit"]["logLikel"]))) < control$tol)& (max(abs(object["Coef"] - oldcoef))/(0.1 + max(abs(object["Coef"]))) < control$tol)) break
}
return(object)
}
setMethod(f="iteraEM",signature=c("MSM.linear","data.frame","ANY"),definition=.MSM.linear.iteraEM)
####em
.MSM.em=function(object,control){
k=object["k"]
swi=object["switch"]
co=object["Coef"]
constX=function(el,swit){
if(swit){ mat=diag(1,k) }else{ mat=rep(1,k)}
kronecker(el,mat)
}
Xini=model.matrix(object["model"])
X=NULL
for(i in 1:ncol(Xini)){ X=cbind(X,constX(Xini[,i,drop=F],swi[i])) }
y=kronecker(as.matrix(object["model"]$model[,1,drop=F]),rep(1,k))
dades=data.frame(y=y,X)
mprob=object@transMat[-1,,drop=F]
object@transMat=matrix(c(1-apply(mprob,2, function(x) sum(x)),mprob),nrow=object["k"],byrow=T)
object@transMat[object@transMat<0]=0
object@transMat[object@transMat>1]=1
object=msmSmooth(object)
maxiterInner=control$maxiterInner
maxiterOuter=control$maxiterOuter
parallelization=control$parallelization
if(parallelization){
mc=detectCores(logical = TRUE)
cl <- makeCluster(mc)
#clusterExport(cl,c("dades","object","control","maxiterInner"))
}
paralel=function(id){
x<-object
smoTransMat=lapply(vector("list",nrow(x@Fit@filtProb)),function(el){
ma=runif(k*k)
matrix(ma/sum(ma),ncol=k)
})
smoTransMatrob=rbind(t(sapply(smoTransMat,function(el)apply(el,1,sum))),runif(k))
x@Fit@smoTransMat<-smoTransMat
x@Fit@smoProb=smoTransMatrob
x=iteraEM(x,dades,control=list(maxiter=maxiterInner,tol=control$tol,trace=control$trace,parallelization=control$parallelization))
return(list(Minim=x@Fit@logLikel,inismoTransMat=x@Fit@smoTransMat,inismoTransMatrob=x@Fit@smoProb))
}
if(parallelization){
junk <- clusterEvalQ(cl, library(MSwM))
paralRes=parLapply(cl, c(1:maxiterOuter),paralel)
stopCluster(cl)
} else {
paralRes=lapply(c(1:maxiterOuter),paralel)
}
Minim=paralRes[[1]][["Minim"]]
inismoTransMat=paralRes[[1]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[1]][["inismoTransMatrob"]]
i=2
while(i<=maxiterOuter){
if(Minim>paralRes[[i]][["Minim"]]){
Minim=paralRes[[i]][["Minim"]]
inismoTransMat=paralRes[[i]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[i]][["inismoTransMatrob"]]
}
i=i+1
}
if (control$trace) cat("Initial Value:",Minim,"\n")
object@Fit@smoTransMat=inismoTransMat
object@Fit@smoProb=inismoTransMatrob
object=iteraEM(object,dades,control)
if (control$trace) cat("Calculating standard errors...\n")
object=hessian(object)
return(object)
}
setMethod(f="em",signature=c("MSM.linear","list"),definition=.MSM.em)
object=msmSmooth(object)
object=MSwM2::msmSmooth(object)
set.seed(12)
mod_mswm <- MSwM2::msmFit(mod,k=3,p=1,sw=rep(T,length(mod$coefficients)+1+1),control=list(trace=F,parallel=F))
