summary(ans)
predictor <- c("RrcConnectionSetupComplete","Paging","X2HandoverRequest","DuProdName","Fdd.Tdd","NumCells")
fmla <- as.formula(paste("TotCpu ~ ", paste(predictor, collapse= "+")))
mod <- lm(fmla, data=train_g2_L16B)
k=3
p=1
sw=rep(T,length(mod$coefficients)+p+1)
control=list(trace = T,  maxiter = 500, tol = 1e-8, maxiterInner=10, maxiterOuter=5, parallelization=F)
data <- train_g2_L16B
object <- mod
mod
object
str(train_g2_L16B)
str(object$model)
summary(ans)
if(!missing(data)){
if(is.list(data)){
if(class(data[[1]])=="call"){
call=data[[1]]
}else{
call=match.call()
}
}else{
call=match.call()
}
}else{
call=match.call()
}
if(missing(p)) p=0
if (missing(control)) control=list()
control  <- do.call(msmControl, control)
###
# Add: use reref() and update model
###
for(i in names(object$contrasts)){
object$model[,i] <- reref(object$model, i)
}
object <- update(object, data=data.frame(object$model))
if(p>0){
var=object$model[,1]
Ar=apply(as.matrix(1:p),1,function(el){
length(var)=length(var)-el
var=c(rep(NA,el),var)
return(var)
}
)
colnames(Ar)=paste(names(object$model)[1],"_",1:p,sep="")
aux=paste(colnames(Ar),collapse="+")
object=update(formula=as.formula(paste("~.+",aux,sep="")),data=data.frame(object$model,Ar),object)
}
####
# Add: check for categorical variables then apply the function
###
if(!is.null(object$contrasts)){
result <- MSM.lm.categorical(object,k)
Coef <- result$Coef
std <- result$std
ind <- result$index
}else{
Coef=data.frame(matrix(NA,nrow=k,ncol=length(coef(object))))
names(Coef)=names(coef(object))
std=rep(0,k)
####
# Add: resample and fit model again if one of the coefficient is not estimated (NA)
####
for(i in 1:k){
mod1=update(object,formula=object$terms,data=object$model)
Coef[i,]=coef(mod1)
std[i]=summary(mod1)$sigma
}
}
set.seed(1)
transMat=t(matrix(table(ind,c(ind[-1],NA))/rep(table(ind[-length(ind)]),k),ncol=k))
ans=new(Class="MSM.lm",
call=as.call(call),
model=object,
k=k,
switch=sw,
p=p,
Coef=Coef,
std=std,
transMat=transMat,
iniProb= rep(1/k,k)
)
validMSM.linear(ans)
validMSM.lm(ans)
ans=em(ans,control)
summary(ans)
object
mod
object <- mod
if(!missing(data)){
if(is.list(data)){
if(class(data[[1]])=="call"){
call=data[[1]]
}else{
call=match.call()
}
}else{
call=match.call()
}
}else{
call=match.call()
}
if(missing(p)) p=0
if (missing(control)) control=list()
control  <- do.call(msmControl, control)
###
# Add: use reref() and update model
###
for(i in names(object$contrasts)){
object$model[,i] <- reref(object$model, i)
}
object <- update(object, data=data.frame(object$model))
if(p>0){
var=object$model[,1]
Ar=apply(as.matrix(1:p),1,function(el){
length(var)=length(var)-el
var=c(rep(NA,el),var)
return(var)
}
)
colnames(Ar)=paste(names(object$model)[1],"_",1:p,sep="")
aux=paste(colnames(Ar),collapse="+")
object=update(formula=as.formula(paste("~.+",aux,sep="")),data=data.frame(object$model,Ar),object)
}
Coef=data.frame(matrix(NA,nrow=k,ncol=length(coef(object))))
names(Coef)=names(coef(object))
std=rep(0,k)
####
# Add: resample and fit model again if one of the coefficient is not estimated (NA)
####
for(i in 1:k){
mod1=update(object,formula=object$terms,data=object$model)
Coef[i,]=coef(mod1)
std[i]=summary(mod1)$sigma
}
set.seed(1)
transMat=t(matrix(table(ind,c(ind[-1],NA))/rep(table(ind[-length(ind)]),k),ncol=k))
ans=new(Class="MSM.lm",
call=as.call(call),
model=object,
k=k,
switch=sw,
p=p,
Coef=Coef,
std=std,
transMat=transMat,
iniProb= rep(1/k,k)
)
validMSM.linear(ans)
validMSM.lm(ans)
ans=em(ans,control)
summary(ans)
matrix(rep(1/k),ncol=k)
matrix(rep(1/k),ncol=k,nrow=k)
m<-matrix(rep(1/k),ncol=k,nrow=k)
colSums(m)
m<-matrix(rep(1/2),ncol=2,nrow=2)
m
ind
t(matrix(table(ind,c(ind[-1],NA))/rep(table(ind[-length(ind)]),k),ncol=k))
table(ind[-length(ind)])
rep(table(ind[-length(ind)]),k)
table(ind,c(ind[-1],NA)
)
31 +16+ 26
data("example.csv")
setwd("~/Thesis/Data")
data("example.csv")
setwd("~/Thesis/Data")
?example
View(example)
library(readr)
dataset <- read_csv(NULL)
View(dataset)
read.csv("example.csv")
example <- read.csv("example.csv")
View(example)
mod=lm(y~x,example)
summary(mod)
k=2
sw=c(T,T,T,T)
object <- mod
set.seed(1)
if(!missing(data)){
if(is.list(data)){
if(class(data[[1]])=="call"){
call=data[[1]]
}else{
call=match.call()
}
}else{
call=match.call()
}
}else{
call=match.call()
}
if(missing(p)) p=0
if (missing(control)) control=list()
control  <- do.call(msmControl, control)
###
# Add: use reref() and update model
###
for(i in names(object$contrasts)){
object$model[,i] <- reref(object$model, i)
}
object <- update(object, data=data.frame(object$model))
if(p>0){
var=object$model[,1]
Ar=apply(as.matrix(1:p),1,function(el){
length(var)=length(var)-el
var=c(rep(NA,el),var)
return(var)
}
)
colnames(Ar)=paste(names(object$model)[1],"_",1:p,sep="")
aux=paste(colnames(Ar),collapse="+")
object=update(formula=as.formula(paste("~.+",aux,sep="")),data=data.frame(object$model,Ar),object)
}
####
# Add: check for categorical variables then apply the function
###
# if(!is.null(object$contrasts)){
#   result <- MSM.lm.categorical(object,k)
#   Coef <- result$Coef
#   std <- result$std
#   ind <- result$index
# }else{
Coef=data.frame(matrix(NA,nrow=k,ncol=length(coef(object))))
names(Coef)=names(coef(object))
std=rep(0,k)
####
# Add: use the whole data set to get the initial coefficients
####
for(i in 1:k){
mod1=update(object,formula=object$terms,data=object$model)
Coef[i,]=coef(mod1)
std[i]=summary(mod1)$sigma
}
# }
####
# Add: initialize transition matrix
###
transMat=t(matrix(rep(1/k),ncol=k,nrow=k))
ans=new(Class="MSM.lm",
call=as.call(call),
model=object,
k=k,
switch=sw,
p=p,
Coef=Coef,
std=std,
transMat=transMat,
iniProb= rep(1/k,k)
)
validMSM.linear(ans)
validMSM.lm(ans)
set.seed(!)
set.seed(1)
ans=em(ans,control)
summary(ans)
k=3;p=1;sw=c(T,T,T,T)
mod
set.seed(1)
if(!missing(data)){
if(is.list(data)){
if(class(data[[1]])=="call"){
call=data[[1]]
}else{
call=match.call()
}
}else{
call=match.call()
}
}else{
call=match.call()
}
if(missing(p)) p=0
if (missing(control)) control=list()
control  <- do.call(msmControl, control)
###
# Add: use reref() and update model
###
for(i in names(object$contrasts)){
object$model[,i] <- reref(object$model, i)
}
object <- update(object, data=data.frame(object$model))
if(p>0){
var=object$model[,1]
Ar=apply(as.matrix(1:p),1,function(el){
length(var)=length(var)-el
var=c(rep(NA,el),var)
return(var)
}
)
colnames(Ar)=paste(names(object$model)[1],"_",1:p,sep="")
aux=paste(colnames(Ar),collapse="+")
object=update(formula=as.formula(paste("~.+",aux,sep="")),data=data.frame(object$model,Ar),object)
}
Coef=data.frame(matrix(NA,nrow=k,ncol=length(coef(object))))
names(Coef)=names(coef(object))
std=rep(0,k)
####
# Add: no need to divide data
#      use the whole data to get the initial coefficients
####
for(i in 1:k){
mod1=update(object,formula=object$terms,data=object$model)
Coef[i,]=coef(mod1)
std[i]=summary(mod1)$sigma
}
####
# Add: initialize transition matrix
###
ind = sample(1:k, length(object$residuals), replace = T)
transMat = t(matrix(table(ind, c(ind[-1], NA))/rep(table(ind[-length(ind)]),
k), ncol = k))
# transMat=t(matrix(rep(1/k),ncol=k,nrow=k))
ans=new(Class="MSM.lm",
call=as.call(call),
model=object,
k=k,
switch=sw,
p=p,
Coef=Coef,
std=std,
transMat=transMat,
iniProb= rep(1/k,k)
)
validMSM.linear(ans)
validMSM.lm(ans)
ans=em(ans,control)
summary(ans)
set.seed(1)
ind = sample(1:k, length(object$residuals), replace = T)
ind
transMat = t(matrix(table(ind, c(ind[-1], NA))/rep(table(ind[-length(ind)]),
k), ncol = k))
transMat
mod
object <- mod
set.seed(1)
if(!missing(data)){
if(is.list(data)){
if(class(data[[1]])=="call"){
call=data[[1]]
}else{
call=match.call()
}
}else{
call=match.call()
}
}else{
call=match.call()
}
if(missing(p)) p=0
if (missing(control)) control=list()
control  <- do.call(msmControl, control)
###
# Add: use reref() and update model
###
for(i in names(object$contrasts)){
object$model[,i] <- reref(object$model, i)
}
object <- update(object, data=data.frame(object$model))
if(p>0){
var=object$model[,1]
Ar=apply(as.matrix(1:p),1,function(el){
length(var)=length(var)-el
var=c(rep(NA,el),var)
return(var)
}
)
colnames(Ar)=paste(names(object$model)[1],"_",1:p,sep="")
aux=paste(colnames(Ar),collapse="+")
object=update(formula=as.formula(paste("~.+",aux,sep="")),data=data.frame(object$model,Ar),object)
}
Coef=data.frame(matrix(NA,nrow=k,ncol=length(coef(object))))
names(Coef)=names(coef(object))
std=rep(0,k)
####
# Add: no need to divide data
#      use the whole data to get the initial coefficients
####
for(i in 1:k){
mod1=update(object,formula=object$terms,data=object$model)
Coef[i,]=coef(mod1)
std[i]=summary(mod1)$sigma
}
####
# Add: initialize transition matrix
###
ind = sample(1:k, length(object$residuals), replace = T)
transMat = t(matrix(table(ind, c(ind[-1], NA))/rep(table(ind[-length(ind)]),
k), ncol = k))
# transMat=t(matrix(rep(1/k),ncol=k,nrow=k))
ans=new(Class="MSM.lm",
call=as.call(call),
model=object,
k=k,
switch=sw,
p=p,
Coef=Coef,
std=std,
transMat=transMat,
iniProb= rep(1/k,k)
)
validMSM.linear(ans)
validMSM.lm(ans)
ans=em(ans,control)
library(MSwM2)
load("~/Thesis/Data/data.RData")
predictor <- c("RrcConnectionSetupComplete","Paging","X2HandoverRequest","DuProdName","Fdd.Tdd","NumCells")
fmla <- as.formula(paste("TotCpu ~ ", paste(predictor, collapse= "+")))
mod_L16B <- lm(fmla, data=train_g2_L16B)
summary(mod_L16B)
set.seed(1)
mswm_L16B_3 <- MSwM2::msmFit(mod_L16B, k=3, p=1, sw=rep(TRUE,length(mod_L16B$coefficients)+1+1), control=list(trace=TRUE, maxiter=500, parallel=FALSE))
summary(mswm_L16B_3)
set.seed(1)
mswm_L16B_2 <- MSwM2::msmFit(mod_L16B, k=3, p=1, sw=rep(TRUE,length(mod_L16B$coefficients)+1+1), control=list(trace=TRUE, maxiter=500, parallel=FALSE))
summary(mswm_L16B_2)
load("~/Thesis/Data/data.RData")
# RUN EVERY TIME
setwd("C:/Users/EARAEAM/Dropbox/Thesis/Data")
setwd("C:/Users/EARAEAM/Documents/Thesis/Data")
library(data.table)
library(gtools) # for sorting RW column
library(dplyr)
library(stringr)
library(ggplot2)
library(ecp)
library(glmnet)
View(g2_extract_filter)
colnames(g2_extract_filter)[which(colnames(g2_extract_filter)=="TotCpu%")] <- "TotCpu"
colnames(g2_extract_filter)[which(colnames(g2_extract_filter)=="Fdd/Tdd")] <- "Fdd.Tdd"
g2_L16A_filter <- get_subset(g2_extract_filter, "L16A")
g2_L16B_filter <- get_subset(g2_extract_filter, "L16B")
g2_L17A_filter <- get_subset(g2_extract_filter, "L17A")
g2_L17B_filter <- get_subset(g2_extract_filter, "L17B")
View(g2_L16B_filter)
predictor <- c("RrcConnectionSetupComplete","Paging","X2HandoverRequest","DuProdName","Fdd.Tdd","NumCells")
fmla <- as.formula(paste("TotCpu ~ ", paste(predictor, collapse= "+")))
num <- 0.9
train_g2_L16A_filter <- train_test(g2_L16A_filter, num)$train
test_g2_L16A_filter <- train_test(g2_L16A_filter, num)$test
train_g2_L16B_filter <- train_test(g2_L16B_filter, num)$train
test_g2_L16B_filter <- train_test(g2_L16B_filter, num)$test
train_g2_L17A_filter <- train_test(g2_L17A_filter, num)$train
test_g2_L17A_filter <- train_test(g2_L17A_filter, num)$test
mod <- lm(fmla, data=train_g2_L16B_filter)
summary(mod)
predictor <- c("RrcConnectionSetupComplete","DuProdName","Fdd.Tdd","NumCells")
fmla <- as.formula(paste("TotCpu ~ ", paste(predictor, collapse= "+")))
mod <- lm(fmla, data=train_g2_L16B_filter)
summary(mod)
View(train_g2_L16A_filter)
View(train_g2_L16B)
View(train_g2_L16B_filter)
predictor <- c("RrcConnectionSetupComplete","NumCells")
fmla <- as.formula(paste("TotCpu ~ ", paste(predictor, collapse= "+")))
mod <- lm(fmla, data=train_g2_L16B_filter)
summary(mod)
View(train_g2_L16B_filter)
get_max <- function(data, y){
require("lazyeval")
sw_name <- unique(data$SW)
if(isTRUE(length(sw_name) <1)){stop("No data for this value")}
subset <- lapply(sw_name, function(x) filter(data, SW == x))
sw_max <- unlist(lapply(1:length(subset), function(x) max(subset[x][[1]][,y])))
subset_max <- data.frame()
for(i in 1:length(sw_name)){
filter_criteria <- interp(~y == x, .values=list(y=as.name(y), x=sw_max[i]))
s <- data %>% filter(SW == sw_name[i]) %>% filter_(filter_criteria)
if(nrow(s) > 1){ # in case there are duplicate rows
s <- s %>% distinct(SW, paste(y), .keep_all = TRUE)
s <- s[,-length(s)] # discard the generated new column
}
subset_max <- bind_rows(subset_max, s)
}
return(subset_max)
}
get_subset <- function(data, release){
data <- data[which(Release == release)]
data1 <- get_max(data, "TotCpu")
# DuProdName, Fdd/Tdd, NumCells to factor
data1$DuProdName <- as.factor(data1$DuProdName)
data1$Fdd.Tdd <- as.factor(data1$Fdd.Tdd)
data1$NumCells <- as.factor(data1$NumCells)
# change SW from character to factor and set the factor levels to be the same as in factor labels
level <- unique(data1$SW)
data1$SW <- factor(data1$SW, levels=level)
return(data1)
}
g2_L16A <- get_subset(g2_extract, "L16A")
g2_L16B <- get_subset(g2_extract, "L16B")
g2_L17A <- get_subset(g2_extract, "L17A")
g2_L17B <- get_subset(g2_extract, "L17B")
View(g2_L16A)
num <- 0.9
train_g2_L16A <- train_test(g2_L16A, num)$train
test_g2_L16A <- train_test(g2_L16A, num)$test
train_g2_L16B <- train_test(g2_L16B, num)$train
test_g2_L16B <- train_test(g2_L16B, num)$test
train_g2_L17A <- train_test(g2_L17A, num)$train
test_g2_L17A <- train_test(g2_L17A, num)$test
plot(density(train_g2_L16B$TotCpu))
plot(density(train_g2_L16A$TotCpu))
plot(density(train_g2_L17A$TotCpu))
plot(train_g2_L16B$TotCpu)
plot(train_g2_L16B$TotCpu, type="l")
