k=object["k"]
sw=object["switch"]
co=object["Coef"]
w=object["Fit"]["smoProb"][-1,]
modaux=glm(y~.-1,dades,weights=c(t(w)),family=object["model"]$family)
object@Coef=as.data.frame(matrix(rep(coef(modaux),rep(ifelse(sw,1,k),ifelse(sw,k,1))),nrow=k))
names(object@Coef)=names(co)
return(object)
}
setMethod(f="maximEM",signature=c("MSM.glm","data.frame"),definition=.MSM.glm.maximEM)
.MSM.linear.iteraEM=function(object,dades,control){
k=object["k"]
for (it in 1:control$maxiter){
oldcoef=object["Coef"]
oldll=object["Fit"]["logLikel"]
##M-step
object=maximEM(object,dades)
smoTransMatrob=object["Fit"]["smoProb"]
smoTransMat=object["Fit"]["smoTransMat"]
object@transMat=matrix(apply(matrix(unlist(smoTransMat),nrow=k*k),1,sum)/rep(apply(smoTransMatrob[-1,],2,sum),rep(k,k)),ncol=k)
object@iniProb=object["Fit"]["smoProb"][1,]
##E-step
object=msmSmooth(object)
if (control$trace) cat(" Inner Iter.",it," logLikel=",object["Fit"]["logLikel"],"\n")
if ( (max(abs(object["Fit"]["logLikel"] - oldll))/(0.1 + max(abs(object["Fit"]["logLikel"]))) < control$tol)
& (max(abs(object["Coef"] - oldcoef),na.rm=TRUE)/(0.1 + max(abs(object["Coef"]),na.rm=TRUE)) < control$tol) ) break
}
return(object)
}
setMethod(f="iteraEM",signature=c("MSM.linear","data.frame","ANY"),definition=.MSM.linear.iteraEM)
####em
.MSM.em=function(object,control){
k=object["k"]
swi=object["switch"]
co=object["Coef"]
constX=function(el,swit){
if(swit){ mat=diag(1,k) }else{ mat=rep(1,k)}
kronecker(el,mat)
}
Xini=model.matrix(object["model"])
X=NULL
for(i in 1:ncol(Xini)){ X=cbind(X,constX(Xini[,i,drop=F],swi[i])) }
y=kronecker(as.matrix(object["model"]$model[,1,drop=F]),rep(1,k))
dades=data.frame(y=y,X)
mprob=object@transMat[-1,,drop=F]
object@transMat=matrix(c(1-apply(mprob,2, function(x) sum(x)),mprob),nrow=object["k"],byrow=T)
object@transMat[object@transMat<0]=0
object@transMat[object@transMat>1]=1
object=msmSmooth(object)
maxiterInner=control$maxiterInner
maxiterOuter=control$maxiterOuter
parallelization=control$parallelization
if(parallelization){
mc=detectCores(logical = TRUE)
cl <- makeCluster(mc)
#clusterExport(cl,c("dades","object","control","maxiterInner"))
}
paralel=function(id){
x<-object
smoTransMat=lapply(vector("list",nrow(x@Fit@filtProb)),function(el){
ma=runif(k*k)
matrix(ma/sum(ma),ncol=k)
})
smoTransMatrob=rbind(t(sapply(smoTransMat,function(el)apply(el,1,sum))),runif(k))
x@Fit@smoTransMat<-smoTransMat
x@Fit@smoProb=smoTransMatrob
x=iteraEM(x,dades,control=list(maxiter=maxiterInner,tol=control$tol,trace=control$trace,parallelization=control$parallelization))
return(list(Minim=x@Fit@logLikel,inismoTransMat=x@Fit@smoTransMat,inismoTransMatrob=x@Fit@smoProb))
}
if(parallelization){
junk <- clusterEvalQ(cl, library(MSwM))
paralRes=parLapply(cl, c(1:maxiterOuter),paralel)
stopCluster(cl)
} else {
paralRes=lapply(c(1:maxiterOuter),paralel)
}
Minim=paralRes[[1]][["Minim"]]
inismoTransMat=paralRes[[1]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[1]][["inismoTransMatrob"]]
i=2
while(i<=maxiterOuter){
if(Minim>paralRes[[i]][["Minim"]]){
Minim=paralRes[[i]][["Minim"]]
inismoTransMat=paralRes[[i]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[i]][["inismoTransMatrob"]]
}
i=i+1
}
if (control$trace) cat("Initial Value:",Minim,"\n")
object@Fit@smoTransMat=inismoTransMat
object@Fit@smoProb=inismoTransMatrob
object=iteraEM(object,dades,control)
if (control$trace) cat("Calculating standard errors...\n")
object=hessian(object)
return(object)
}
setMethod(f="em",signature=c("MSM.linear","list"),definition=.MSM.em)
##########
##### predict
.MSM.lm.predict=function(object, newdata){
p <- object@p
k <- object["k"]
model <- object["model"]
Coef <- object["Coef"]
std <- object["std"]
P <- object["transMat"]
fProb <- object["Fit"]["filtProb"]
margLik <- object["Fit"]["margLik"]
nr <- length(model$model[,1])
var_name <- colnames(model$model) # all variables name
var_name <- var_name[1:(length(var_name)-p)] # discard AR term (if any)
test <- subset(newdata, select=var_name) # subset (dependent and independent variables)
if(p > 0){
ar <- t(model$model[nr:(nr-p+1),1,drop=F]) # lag p from training data
var <- test[,1]
if(length(var) > 1){
ar <- apply(as.matrix(1:p),1,function(el){
length(var)=length(var)-el
var=c(rep(ar[el:1]),var)
return(var)
})}
colnames(ar) <- paste(names(model$model)[1],"_",1:p,sep="") # insert name
}
test <- cbind(test, ar) # include back AR term
# relevel the reference of the factor level to be the same as in the training model
for(i in names(model$xlevels)){
ref_level <- model$xlevels[[i]][1]
test[,i] <- relevel(test[,i], ref_level)
}
terms <- model.matrix(as.formula(paste(colnames(test)[1], " ~ ", paste(colnames(test)[-1], collapse= "+"))), data=test)
CondMean <- as.matrix(terms) %*% t(as.matrix(Coef))
error <- as.matrix(test[,1,drop=F]) %*% matrix(rep(1,k),nrow=1) - CondMean
Likel <- t(dnorm(t(error),0,std))
st <- c()
for(i in 1:nrow(test)){
fProb_new <- t(P %*% t(fProb[nr-1+i,,drop=F])) * (Likel[i,,drop=F])
margLik_new <- sum(fProb_new)
fProb_new <- (fProb_new / margLik_new)
fProb <- rbind(fProb, fProb_new) # filtered prob of t+1 conditional on the info in t+1
margLik <- rbind(margLik, margLik_new)
st <- c(st, which.max(fProb_new))
}
names(st) <- seq(nrow(test))
return(st)
}
setMethod(f="predict",signature=c("MSM.lm","data.frame"),definition=.MSM.lm.predict)
predictor <- c("RrcConnectionSetupComplete","Paging","X2HandoverRequest","DuProdName","Fdd.Tdd","NumCells")
fmla <- as.formula(paste("TotCpu ~ ", paste(predictor, collapse= "+")))
mod <- lm(fmla, data=train_g2_L16A)
k=3
p=1
control=list(trace = T,  maxiter = 500, tol = 1e-8, maxiterInner=10, maxiterOuter=5, parallelization=F)
data <- train_g2_L16B
object <- mod
set.seed(1)
if(!missing(data)){
if(is.list(data)){
if(class(data[[1]])=="call"){
call=data[[1]]
}else{
call=match.call()
}
}else{
call=match.call()
}
}else{
call=match.call()
}
if(missing(p)) p=0
if (missing(control)) control=list()
control  <- do.call(msmControl, control)
###
# Add: use reref() and update model
###
for(i in names(object$contrasts)){
object$model[,i] <- reref(object$model, i)
}
object <- update(object, data=data.frame(object$model))
if(p>0){
var=object$model[,1]
Ar=apply(as.matrix(1:p),1,function(el){
length(var)=length(var)-el
var=c(rep(NA,el),var)
return(var)
}
)
colnames(Ar)=paste(names(object$model)[1],"_",1:p,sep="")
aux=paste(colnames(Ar),collapse="+")
object=update(formula=as.formula(paste("~.+",aux,sep="")),data=data.frame(object$model,Ar),object)
}
Coef=data.frame(matrix(NA,nrow=k,ncol=length(coef(object))))
names(Coef)=names(coef(object))
std=rep(0,k)
####
# Add: no need to divide data
#      use the whole data to get the initial coefficients
####
for(i in 1:k){
mod1=update(object,formula=object$terms,data=object$model)
Coef[i,]=coef(mod1)
std[i]=summary(mod1)$sigma
}
ind = sample(1:k, length(object$residuals), replace = T)
transMat = t(matrix(table(ind, c(ind[-1], NA))/rep(table(ind[-length(ind)]), k), ncol = k))
ans=new(Class="MSM.lm",
call=as.call(call),
model=object,
k=k,
switch=sw,
p=p,
Coef=Coef,
std=std,
transMat=transMat,
iniProb= rep(1/k,k)
)
validMSM.linear(ans)
validMSM.lm(ans)
sw=rep(T,length(mod$coefficients)+p+1)
sw[c(6,7)] <- FALSE
control=list(trace = T,  maxiter = 500, tol = 1e-8, maxiterInner=10, maxiterOuter=5, parallelization=F)
data <- train_g2_L16B
object <- mod
set.seed(1)
if(!missing(data)){
if(is.list(data)){
if(class(data[[1]])=="call"){
call=data[[1]]
}else{
call=match.call()
}
}else{
call=match.call()
}
}else{
call=match.call()
}
if(missing(p)) p=0
if (missing(control)) control=list()
control  <- do.call(msmControl, control)
###
# Add: use reref() and update model
###
for(i in names(object$contrasts)){
object$model[,i] <- reref(object$model, i)
}
object <- update(object, data=data.frame(object$model))
if(p>0){
var=object$model[,1]
Ar=apply(as.matrix(1:p),1,function(el){
length(var)=length(var)-el
var=c(rep(NA,el),var)
return(var)
}
)
colnames(Ar)=paste(names(object$model)[1],"_",1:p,sep="")
aux=paste(colnames(Ar),collapse="+")
object=update(formula=as.formula(paste("~.+",aux,sep="")),data=data.frame(object$model,Ar),object)
}
Coef=data.frame(matrix(NA,nrow=k,ncol=length(coef(object))))
names(Coef)=names(coef(object))
std=rep(0,k)
####
# Add: no need to divide data
#      use the whole data to get the initial coefficients
####
for(i in 1:k){
mod1=update(object,formula=object$terms,data=object$model)
Coef[i,]=coef(mod1)
std[i]=summary(mod1)$sigma
}
ind = sample(1:k, length(object$residuals), replace = T)
transMat = t(matrix(table(ind, c(ind[-1], NA))/rep(table(ind[-length(ind)]), k), ncol = k))
ans=new(Class="MSM.lm",
call=as.call(call),
model=object,
k=k,
switch=sw,
p=p,
Coef=Coef,
std=std,
transMat=transMat,
iniProb= rep(1/k,k)
)
validMSM.linear(ans)
validMSM.lm(ans)
set.seed(1)
object <- an
set.seed(1)
object <- ans
k=object["k"]
swi=object["switch"]
co=object["Coef"]
constX=function(el,swit){
if(swit){ mat=diag(1,k) }else{ mat=rep(1,k)}
kronecker(el,mat)
}
Xini=model.matrix(object["model"])
X=NULL
for(i in 1:ncol(Xini)){ X=cbind(X,constX(Xini[,i,drop=F],swi[i])) }
y=kronecker(as.matrix(object["model"]$model[,1,drop=F]),rep(1,k))
dades=data.frame(y=y,X)
mprob=object@transMat[-1,,drop=F]
object@transMat=matrix(c(1-apply(mprob,2, function(x) sum(x)),mprob),nrow=object["k"],byrow=T)
object@transMat[object@transMat<0]=0
object@transMat[object@transMat>1]=1
object=msmSmooth(object)
maxiterInner=control$maxiterInner
maxiterOuter=control$maxiterOuter
parallelization=control$parallelization
if(parallelization){
mc=detectCores(logical = TRUE)
cl <- makeCluster(mc)
#clusterExport(cl,c("dades","object","control","maxiterInner"))
}
paralel=function(id){
x<-object
smoTransMat=lapply(vector("list",nrow(x@Fit@filtProb)),function(el){
ma=runif(k*k)
matrix(ma/sum(ma),ncol=k)
})
smoTransMatrob=rbind(t(sapply(smoTransMat,function(el)apply(el,1,sum))),runif(k))
x@Fit@smoTransMat<-smoTransMat
x@Fit@smoProb=smoTransMatrob
x=iteraEM(x,dades,control=list(maxiter=maxiterInner,tol=control$tol,trace=control$trace,parallelization=control$parallelization))
return(list(Minim=x@Fit@logLikel,inismoTransMat=x@Fit@smoTransMat,inismoTransMatrob=x@Fit@smoProb))
}
if(parallelization){
junk <- clusterEvalQ(cl, library(MSwM))
paralRes=parLapply(cl, c(1:maxiterOuter),paralel)
stopCluster(cl)
} else {
paralRes=lapply(c(1:maxiterOuter),paralel)
}
Minim=paralRes[[1]][["Minim"]]
inismoTransMat=paralRes[[1]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[1]][["inismoTransMatrob"]]
i=2
while(i<=maxiterOuter){
if(Minim>paralRes[[i]][["Minim"]]){
Minim=paralRes[[i]][["Minim"]]
inismoTransMat=paralRes[[i]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[i]][["inismoTransMatrob"]]
}
i=i+1
}
if (control$trace) cat("Initial Value:",Minim,"\n")
object@Fit@smoTransMat=inismoTransMat
object@Fit@smoProb=inismoTransMatrob
object=iteraEM(object,dades,control)
if (control$trace) cat("Calculating standard errors...\n")
set.seed(1)
object <- ans
k=object["k"]
swi=object["switch"]
co=object["Coef"]
constX=function(el,swit){
if(swit){ mat=diag(1,k) }else{ mat=rep(1,k)}
kronecker(el,mat)
}
Xini=model.matrix(object["model"])
X=NULL
for(i in 1:ncol(Xini)){ X=cbind(X,constX(Xini[,i,drop=F],swi[i])) }
y=kronecker(as.matrix(object["model"]$model[,1,drop=F]),rep(1,k))
dades=data.frame(y=y,X)
mprob=object@transMat[-1,,drop=F]
object@transMat=matrix(c(1-apply(mprob,2, function(x) sum(x)),mprob),nrow=object["k"],byrow=T)
object@transMat[object@transMat<0]=0
object@transMat[object@transMat>1]=1
object=msmSmooth(object)
maxiterInner=control$maxiterInner
maxiterOuter=control$maxiterOuter
parallelization=control$parallelization
if(parallelization){
mc=detectCores(logical = TRUE)
cl <- makeCluster(mc)
#clusterExport(cl,c("dades","object","control","maxiterInner"))
}
paralel=function(id){
x<-object
smoTransMat=lapply(vector("list",nrow(x@Fit@filtProb)),function(el){
ma=runif(k*k)
matrix(ma/sum(ma),ncol=k)
})
smoTransMatrob=rbind(t(sapply(smoTransMat,function(el)apply(el,1,sum))),runif(k))
x@Fit@smoTransMat<-smoTransMat
x@Fit@smoProb=smoTransMatrob
x=iteraEM(x,dades,control=list(maxiter=maxiterInner,tol=control$tol,trace=control$trace,parallelization=control$parallelization))
return(list(Minim=x@Fit@logLikel,inismoTransMat=x@Fit@smoTransMat,inismoTransMatrob=x@Fit@smoProb))
}
if(parallelization){
junk <- clusterEvalQ(cl, library(MSwM))
paralRes=parLapply(cl, c(1:maxiterOuter),paralel)
stopCluster(cl)
} else {
paralRes=lapply(c(1:maxiterOuter),paralel)
}
Minim=paralRes[[1]][["Minim"]]
inismoTransMat=paralRes[[1]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[1]][["inismoTransMatrob"]]
i=2
while(i<=maxiterOuter){
if(Minim>paralRes[[i]][["Minim"]]){
Minim=paralRes[[i]][["Minim"]]
inismoTransMat=paralRes[[i]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[i]][["inismoTransMatrob"]]
}
i=i+1
}
if (control$trace) cat("Initial Value:",Minim,"\n")
object@Fit@smoTransMat=inismoTransMat
object@Fit@smoProb=inismoTransMatrob
object=iteraEM(object,dades,control)
if (control$trace) cat("Calculating standard errors...\n")
k=object["k"]
swi=object["switch"]
co=object["Coef"]
constX=function(el,swit){
if(swit){ mat=diag(1,k) }else{ mat=rep(1,k)}
kronecker(el,mat)
}
Xini=model.matrix(object["model"])
X=NULL
for(i in 1:ncol(Xini)){ X=cbind(X,constX(Xini[,i,drop=F],swi[i])) }
y=kronecker(as.matrix(object["model"]$model[,1,drop=F]),rep(1,k))
dades=data.frame(y=y,X)
mprob=object@transMat[-1,,drop=F]
object@transMat=matrix(c(1-apply(mprob,2, function(x) sum(x)),mprob),nrow=object["k"],byrow=T)
object@transMat[object@transMat<0]=0
object@transMat[object@transMat>1]=1
object=msmSmooth(object)
maxiterInner=control$maxiterInner
maxiterOuter=control$maxiterOuter
parallelization=control$parallelization
if(parallelization){
mc=detectCores(logical = TRUE)
cl <- makeCluster(mc)
#clusterExport(cl,c("dades","object","control","maxiterInner"))
}
paralel=function(id){
x<-object
smoTransMat=lapply(vector("list",nrow(x@Fit@filtProb)),function(el){
ma=runif(k*k)
matrix(ma/sum(ma),ncol=k)
})
smoTransMatrob=rbind(t(sapply(smoTransMat,function(el)apply(el,1,sum))),runif(k))
x@Fit@smoTransMat<-smoTransMat
x@Fit@smoProb=smoTransMatrob
x=iteraEM(x,dades,control=list(maxiter=maxiterInner,tol=control$tol,trace=control$trace,parallelization=control$parallelization))
return(list(Minim=x@Fit@logLikel,inismoTransMat=x@Fit@smoTransMat,inismoTransMatrob=x@Fit@smoProb))
}
if(parallelization){
junk <- clusterEvalQ(cl, library(MSwM))
paralRes=parLapply(cl, c(1:maxiterOuter),paralel)
stopCluster(cl)
} else {
paralRes=lapply(c(1:maxiterOuter),paralel)
}
Minim=paralRes[[1]][["Minim"]]
inismoTransMat=paralRes[[1]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[1]][["inismoTransMatrob"]]
i=2
while(i<=maxiterOuter){
if(Minim>paralRes[[i]][["Minim"]]){
Minim=paralRes[[i]][["Minim"]]
inismoTransMat=paralRes[[i]][["inismoTransMat"]]
inismoTransMatrob=paralRes[[i]][["inismoTransMatrob"]]
}
i=i+1
}
if (control$trace) cat("Initial Value:",Minim,"\n")
object@Fit@smoTransMat=inismoTransMat
object@Fit@smoProb=inismoTransMatrob
object=iteraEM(object,dades,control)
if (control$trace) cat("Calculating standard errors...\n")
set.seed(1)
if (tail(object["switch"],1)==F){
lstd=log(object["std"][1])
} else {
lstd=log(object["std"])
}
swi=object["switch"][-length(object["switch"])]
param=c(lstd,
logit(matrix(object["transMat"][1:object["k"]-1,],nrow=1,byrow=T)),
object["Coef"][1,!swi],
matrix(t(as.matrix(object["Coef"])[,swi]),nrow=1))
res=fdHess(
pars=param,
fun=fopt.lm,
object=object
)
library("nlme", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library("matlib", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
if (tail(object["switch"],1)==F){
lstd=log(object["std"][1])
} else {
lstd=log(object["std"])
}
swi=object["switch"][-length(object["switch"])]
param=c(lstd,
logit(matrix(object["transMat"][1:object["k"]-1,],nrow=1,byrow=T)),
object["Coef"][1,!swi],
matrix(t(as.matrix(object["Coef"])[,swi]),nrow=1))
res=fdHess(
pars=param,
fun=fopt.lm,
object=object
)
long=length(lstd)+(object["k"]-1)*object["k"]
mi=sum(!swi)
r <- res$Hessian
View(r)
hessian=sqrt(abs(diag(Ginv(res$Hessian))))
